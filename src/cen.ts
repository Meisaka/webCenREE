"use strict";
window.addEventListener('load', async function(){
// hi there
const reset_button = document.getElementById('b_reset') as HTMLButtonElement;
const step_button = document.getElementById('b_step') as HTMLButtonElement;
const run_button = document.getElementById('b_run') as HTMLButtonElement;
const run_rate1 = document.getElementById('b_r1') as HTMLButtonElement;
const run_rate2 = document.getElementById('b_r2') as HTMLButtonElement;
const run_rate3 = document.getElementById('b_r3') as HTMLButtonElement;
const run_rate4 = document.getElementById('b_r4') as HTMLButtonElement;
const run_rate5 = document.getElementById('b_r5') as HTMLButtonElement;
//const run_rate6 = document.getElementById('b_r6') as HTMLButtonElement;
const micro_button = document.getElementById('b_micro') as HTMLButtonElement;
const microstep_button = document.getElementById('b_mstep') as HTMLButtonElement;
const btn_or0 = document.getElementById('or0') as HTMLButtonElement;
const btn_or1 = document.getElementById('or1') as HTMLButtonElement;
const btn_or2 = document.getElementById('or2') as HTMLButtonElement;
const btn_or3 = document.getElementById('or3') as HTMLButtonElement;
const btn_ss1 = document.getElementById('ss1') as HTMLButtonElement;
const btn_ss2 = document.getElementById('ss2') as HTMLButtonElement;
const btn_ss3 = document.getElementById('ss3') as HTMLButtonElement;
const btn_ss4 = document.getElementById('ss4') as HTMLButtonElement;
const btn_dt1 = document.getElementById('diag1') as HTMLButtonElement;
const btn_dt2 = document.getElementById('diag2') as HTMLButtonElement;
const btn_dt4 = document.getElementById('diag4') as HTMLButtonElement;
const btn_dt8 = document.getElementById('diag8') as HTMLButtonElement;
const btn_dtrun = document.getElementById('diagrun') as HTMLButtonElement;
const fp_rf = document.getElementById('fp_r') as HTMLButtonElement;
const fp_load = document.getElementById('fp_l') as HTMLButtonElement;
const fp_select = document.getElementById('fp_s') as HTMLButtonElement;
const mcs_p = document.getElementById('mcs_p') as HTMLSpanElement;
const mcs_s = document.getElementById('mcs_s') as HTMLSpanElement;
const mcs_alu = document.getElementById('mcs_alu') as HTMLSpanElement;
const mcs_alu2 = document.getElementById('mcs_alu2') as HTMLSpanElement;
const mcs_alu3 = document.getElementById('mcs_alu3') as HTMLSpanElement;
const mcr_res = document.getElementById('mcr_res') as HTMLSpanElement;
const mcr_bus = document.getElementById('mcr_bus') as HTMLSpanElement;
const mcr_sys = document.getElementById('mcr_sys') as HTMLSpanElement;
const mcr_addr = document.getElementById('mcr_addr') as HTMLSpanElement;
const mcr_swap = document.getElementById('mcr_swap') as HTMLSpanElement;
const fp_flags_con = document.getElementById('fp_flags') as HTMLSpanElement;
const fp_flags = [
	fp_flags_con.children[7] as HTMLElement,
	fp_flags_con.children[6] as HTMLElement,
	fp_flags_con.children[4] as HTMLElement,
	fp_flags_con.children[5] as HTMLElement,
	fp_flags_con.children[3] as HTMLElement,
	fp_flags_con.children[2] as HTMLElement,
	fp_flags_con.children[1] as HTMLElement,
	fp_flags_con.children[0] as HTMLElement,
];
const fp_runhalt = [
	(document.getElementById('fp_runstate') as HTMLElement).children[0],
	(document.getElementById('fp_runstate') as HTMLElement).children[1],
];
const mcpage = [
	document.getElementById('mcp_0') as HTMLSpanElement,
	document.getElementById('mcp_1') as HTMLSpanElement,
	document.getElementById('mcp_2') as HTMLSpanElement,
	document.getElementById('mcp_3') as HTMLSpanElement,
];
const mcr_file = [
document.getElementById('mcr_file0') as HTMLSpanElement,
document.getElementById('mcr_file2') as HTMLSpanElement,
document.getElementById('mcr_file4') as HTMLSpanElement,
document.getElementById('mcr_file6') as HTMLSpanElement,
document.getElementById('mcr_file8') as HTMLSpanElement,
document.getElementById('mcr_fileA') as HTMLSpanElement,
document.getElementById('mcr_fileC') as HTMLSpanElement,
document.getElementById('mcr_fileE') as HTMLSpanElement];
const mcr_level = document.getElementById('mcr_level') as HTMLSpanElement;
const mcr_rfir = document.getElementById('mcr_rfir') as HTMLSpanElement;
const mcr_rfdr = document.getElementById('mcr_rfdr') as HTMLSpanElement;
const mcr_pta = document.getElementById('mcr_pta') as HTMLSpanElement;
const mcs_op = document.getElementById('mcs_op') as HTMLSpanElement;
const mcs_op_alu = document.getElementById('mcs_op_alu') as HTMLSpanElement;
const mcs_op_bus = document.getElementById('mcs_op_bus') as HTMLSpanElement;
const d_listing = document.getElementById('listing') as HTMLDivElement;
const d_micro = document.getElementById('micro') as HTMLDivElement;
const in_dbgcmd = document.getElementById('dbgcmd') as HTMLInputElement;
const in_dbgdat = document.getElementById('dbgdat') as HTMLInputElement;
const btn_cm_import = document.getElementById('cm_imp') as HTMLButtonElement;
const btn_cm_importclip = document.getElementById('cm_impcb') as HTMLButtonElement;
const btn_cm_clear = document.getElementById('cm_clear') as HTMLButtonElement;
const txt_anno = document.getElementById('anno') as HTMLTextAreaElement;
const cv_diag = document.getElementById('fp_diag') as HTMLCanvasElement;
const cx_diag = cv_diag.getContext('2d') as CanvasRenderingContext2D;
const cv_term0 = document.getElementById('term0') as HTMLCanvasElement;
const cx_term0 = cv_term0.getContext('2d') as CanvasRenderingContext2D;

cx_diag.fillStyle = '#ff3232';
cx_diag.font = '16px monospace';
cx_term0.fillStyle = '#6ac';
cx_term0.strokeStyle = '#6ac';
cx_term0.font = '12px monospace';

const listmax = 100;
const listing:HTMLDivElement[] = [];
(function(){
	for (let i = 0; i < listmax; i++) {
		let listnode = document.createElement('div');
		listing.push(listnode);
		d_listing.appendChild(listnode);
	}
})();

let run_ctl = 0;
let run_rate = 1;
let run_step = 0;
let run_busy = false;
let dis_after = false;
let run_follow = false;
let dis_vpc = 0x100;
let dis_vpc_end = 0x200;
let run_stop:null | (()=>void);
function run_control(run:boolean):void {
	if (!run && (run_ctl !== 0)) {
		clearInterval(run_ctl);
		run_ctl = 0;
		run_step = 0;
		if (!run_busy && run_stop) {run_stop(); run_stop = null; }
		return;
	}
	if (run && (run_ctl == 0)) {
		run_ctl = setInterval(function(){
			run_busy = true;
			if (run_rate <= 100) run_follow = true;
			for (let i=0;i<run_rate;i++) {
				mcstep(i == (run_rate - 1));
				if (run_ctl == 0) {
					if (run_stop) {run_stop(); run_stop = null; }
					break;
				}
			}
			run_busy = false;
			mcshowstate();
			if (dis_after) {
				show_disasm();
			}
		}, 20);
	}
}

function bload(v:string):Uint8Array {
	const bv = atob(v);
	const a = new Uint8Array(bv.length);
	let i = 0;
	for(let c of bv) {
		a[i] = c.charCodeAt(0);
		i++;
	}
	return a;
}
const vtfont = bload(`AAAAAAAAAAAAAAAAAAAAAAAIFBQUQgYEEAQIAAAAAEAACBQUfiUJBAgIKggAAAAgAAgAPhUSCQAE
EBwIAAAAEAAIABQ+CAYABBAIPgA+AAgACAA+VCQpAAQQHAgAAAAEAAAAFD9SEQAICCoIDAAAAgAI
ABQUIS4AEAQIAAgADAEAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAA+CBw+ED4YPhwcAAAgAAQcYQwiIBgCBCAiIgAAEAAIIlEIIBAUHgIQIiIMDAgeECBJCBgY
EiAeCBw8AAAEACAQRQgEID8gIgQiIAwMCB4QCEMIAiIQIiIEIhAACBAACAA+HD4cEBwcBBwIAAQg
AAQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBweHB4+
PhwiHBwiAkEiHCIiIiIiAgIiIggIEgJjJiI6IiICIgICAiIICAoCVSoiKj4eAiIeHgI+CAgGAkky
IjoiIgIiAgIyIggICgJBIiICIiIiIgICIiIICBICQSIiPCIeHB4+AhwiHAYiPkEiHAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4cHhw+IkFBQSI+PgE+CAgi
IiIiCCJBQSIiIAYCMBwEIiIiAggiIkEUIhAGBDAqAh4iHhwIIiJJCBQIBggwSX8CKgogCCIUVRQI
BAYQMAgCAhISIggiFGMiCAIGIDAIBAIsIhwIHAhBQQg+PkA+CAgAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEHB4cHj4+HCIcHCICQSIcCCIiIiICAiIiCAgS
AmMmIhAiIgIiAgICIggICgJVKiIAPh4CIh4eAj4ICAYCSTIiACIiAiICAjIiCAgKAkEiIgAiIiIi
AgIiIggIEgJBIiIAIh4cHj4CHCIcBiI+QSIcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAHhweHD4iQUFBIj4YCAYABiIiIiIIIkFBIiIgBAgIAEkiIiICCCIi
QRQiEAQICAAwHiIeHAgiIkkIFAgCABAAAAIqCiAIIhRVFAgEBAgIAAACEhIiCCIUYyIIAgQICAAA
AiwiHAgcCEFBCD4YCAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=`);
const bpl_rom = bload(`9WVL0AyAfUHVvnOhZQmhZUBV0HM1QPoYKUA3BwSASAovewMBcYQVRPGBABx7Ai8f6pAALwABkAYv
BC/yFFogAMAUGEkFwBkWMUERgA4ZMUEJgCUWSbDAJRRJjcAqFE3n0KAVWgAE0B6UAzt7QfGxOq8U
WhAA0C2UQPGhuhhJB8BMeUAyom2+R5NMeQOzQZUAiwCMCfoVSgn4wdpzCQEVCL9zAnNicwnmpDFC
38AEFkngwDFDgMD1hPsRLO6E73MB+IEDAXEDew17CIAI+KFFgAYvNC8CLx/qkAAvAAGQmnPyoQkB
FUGF+REsLADygRFzc3OFcwcAio3Sz9LSxYqNEQJzIHsODgj4oUOABi80LwIvO4BRAC9AH5AOCPih
Dgj4ewMBcQMVRRV7Ai//8JAALwABkEMiewIv9v+QoC8GLxShKg4I+KFBgE57CICBpf+A8xVJDsAo
gfWQAdCBpSqBpS+i9fsXKTAnBgCB0KL1AIPQouWIwKL1IDKi9QAP0D0YhYCBtTqBpYOAgaUxQA/A
BBShhYGlhICBtQCBkF5AH5BJA8B/GH8WocVIFjFAUMBye1AVScjABRRJw8AKFKLlSaKloHMJ+xAs
34RI8aFBhQn2hPoVKQH4gQD4oUGFAPxxxsByewC9xHl7XwAQkA4OAfKhjIAA8qHFgAGAcQNzAho=`);

const wipl_test = bload(`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
AAAAAAAAAA==`);

const wipl_dump = bload(`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
AAAAAA==`);

const diag = {
f1:bload(`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`),
f2:bload(`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`),
f3:bload(`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`),
f4:bload(`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`),
};
const uc = {
e:bload(`wAAADQABDS2TUnAAUJoAACAAGgoQEAEACoAAAAEQAAAAAAAAgAENAAAAcC0AAAAtCQoAABAQAAAA
AC1QAACdYAAAcBANDQAKCwAAAIAAAQAKGgAQAAAAAIAAAAABAAAAAAAAAYAAcBBQAAAgEgAAAAAA
ABCAAAAAUAIAAAAAHRBQAAAKDQENLRMAAC0AAABQAQAQABAAIBEQgAAAI4AwIFBwEQAKABoAABoA
DQogABAQgAANCw0QnTAQAC1QCgAgAAAAEAABARoAGhAaAAAALQAAAAAAAAAAAAAAAAAAAAAAAAAg
EBAAUAAtEC0AcBBwAHAAAAAAAHAAAAAAAAAAcAAgEGphLQstABARAABamgAAAAAhLQAACgBwEQAA
EBAtABBwEAAQIAoAABAAIAAQECAtABAQICAKABEREQEQIAAQIAAgAQAAABogAQAAAQFwbQAAbQAA
CRpwAHEADSogYAAAAABtAA0AAAABAA0qAAGRYA0aIAAAAAAAcXANDS0TYA0aIABwAAAACiANABAQ
AAANCi0AAAAdEABdcC0AAJANAA1qCmCQAAAAAABQAA1wIA1qCg1hAAANIAAAAAAAACogTS0ADQBw
AAAAAA0ALQAADS0SDRGAEABwAHADAi0AAAAAACFwAAABAAAtLQAtCgAgAIARgEAQCg0tLS0tLQkR
EQBQABERAACQCpACHQAAEREAUJkREQAAkAqQIAAAGhERAFAAEQEAAADwEBoRABEREQANAhAgAHCQ
AJoRABEAEREAECAREQAAkAoKDWAgEBAQEA0NEREAAAB6UBEAAAAAcABQABEgABoACgANIAAtAQEA
UAAQEAANCXodUBAAcAEBAFAAAFAacAEBAQAQIAAAcABQAAAAGgBQAQEQIAAAExIQUJEAAFBwcBER
ADAALQ0REFCRAQAAkHAQGkAAAABQABBQEBAgAAAAAQEAgJGtESAQUAAALX0AcAEBHRAAAAAAEFAQ
EHAQAAAREQAAcBCAABBQAAAKIFAhEABQAC0AGgAAGgAacHABERFwcCBwAJGQAQAAkAAAcACRAAAR
ESARERERERENIBERES0tLS0tAAAACgoKDQAREREqICEBEABwABoAGiBgIABgYB1QEAAAEQAaABoA
UAAAABoAUAAaEAAQACAAABAKGgoaChoQECAAAAqAIAAAChoKGgoaEBATAREtXRERgFAQABAggBAQ
EABQcAAAABNgIBoAAAAAAAoNCgAKAAAAAAAAAAAhAQAAAFAAAFCAAFAAAAABUQAAcGAAAAFgAAAN
AAAAAnAACQBQCoAACgCAAAAQcB0AEBAADQ0RAHBQXQAdUAANDQAAAgMQgABQEBAQIFAggBAAEAAa
AAAaABoQAC0AAACAcAAKAAogGhAaEAAAAAABAAAAEAAaECBQGhBNUAAAAFsADQAAAC0AERoQCAIN
AABQEwoDAAAKAAAaEIBAUC0AUG1gAAAQEABQGhAKAC0AUABtAAAAERFAUFAAcAktcJEAAAAKAACA
AJAKAAAAAF0AUAoAMQAQACARCgCQQAAtbWANE3AALQABGgEgKiANDQAAAAAAAAAAAAAAAAAAAAAA
AA0AAAoNABEADQAAAAANABENDQAAEAAtAAENAAANDW1gcHAAAAoqACAAAAEQEFAQAAEBcQEAChAA
UAqaAS0SABEQEFAQAABQCgBQAABQgFAAABMLERBNgIBQGgAALQEtUAAtAREgACAtEAAAEAATEBAA
AABwEA0tACAAAABQAAoAAAAAEQoKAHAAcABwAABQAAAAUAEKgAAAAB0NEE0aXcBQABBxEBAAAAAA
LRAAcABwAHABDQEAExAAAC0gDSAAAQAAAHEAcBAAgAAtcIBwAAAQAFAAIAABAIAKCgAAcAARkQAA
AABQAACAAAAAAAAAABEAAA0AAIAKgC0AAABwAC0AABoKDQAAAC0QDQAACgBSAA0BAZBQIwAtEABQ
LSAjEC0gEgAAACAtABEAAAAAXRAgABMAAHAtAAAAEwCQAAAKCQAA0ABgAAANAAAKDQAAIABwAIAT
gQAADQkAIBAAAAAAEayQAwAAQ9CQkACQkACQIxIdHR0NQBHQUCAAAFAtIABQEEAAI3BQACANAAAj
AAAAIA0NACMRLQ0gAAsAIAANXVAAAF1dADyaMAAAEC0gCwAQcF0ADQBwmtANAAAgIw0AgAAAAC0A
AJpwUAAAAAAAAAAKAFAKAAAREwsAUCA9AAANDQBQHXAAUABQAAAAEAAAIAAAERARAAAAAAAAAAAA
Cg0AAAAAAAAAAK2QLAAAAC1QAAAAEBEQEVAQAABQgAANAAAADXAAACANAC0AABBQAAAAABFwAAAA
cAAAAA0gDRFwQAAAAAAAMAkAAgAAIwBQIBAAChAAAAAAKgEBAAAAAAAAAFBwDQkADQBQABEgAAAN
DQBQAQoaEBBwkwALIAEAAACBAAAAAAAAEQAMAAwAgAAAAAAAIAARAAABLQAAAC0AEABQcAAAAAAA
AAAAAIAAAAAAAAoAEAEAEAAAcABQUBAIDSCgEAANDYAdAB0BAACAAAENGgBDgIAAAQAAAAtQjQwN
AQ0ALYANLQAAkQAAAAEAIAAAIAANAABQEAAQAAAAABANLQAgLQ0AgBAQEAAACg0AAAAgABAAExAA
ECEAEQABIQoKAJCAAAAAAAAACgAACgCQLQAAUACaAAAADQAKDQAAACoKAQBgAA0AkBGAEAA=`),
f:bload(`qwABEwFjAEs5AwEBAQMBAKIBAQABgQABCzEbAAMBSwE7ASOjAVNLiwABGwEDAQHLABu7AQGBAYEj
AUsBAQGqmiMBBAuBA0kDGwAbAbEBI0O7q4uBAQMBATF1GwEjQwF1IwEBa3mJBAu7dRuBAYmLAwEB
AYFxiYsju3MbIwGJqtoBAQEbAwsDAQEBG0sBARsBCwEBKwEBywEjORu5AbuBgQEBAQG7AQEBAQHL
IxPLAUGBATNbAykButsBSUthIztLAAEAgQEbEwMBgREBAQEBAQEBAyYmJiYmJiYmJiYmJiYmJiZD
gQEAAQEBAQEAAQEBAHQBAQEBASQBAQEBAQGApAHLwjuKEwABEwEBAQG7AQAAAAABSwEBQwEBAQEB
gYEBAYkBgYyBSxsBAQGTSwGBgUtLAcLCubkbAAEBAQMBSwGBAQEBEwEBywFLAAEBAxMBO0MbOxtD
FwEBAQs7QysjKRtDG8O7G0MBAQEAAUMrIwsTASurSwEBQ4EDCwEzMwEBASujS6sBAAAAAcsBAYEB
AQEro0sBIwEBASPLAUtzIwEDAQABIwEBARsBAYHbq1MBywMBIwNCAEMTAQMTARsBExMBigEBAAEB
AQlpAXMZAhEBAwEBAwExAQEjASMTCwIAAZsjAYIBAQGBIwFLAQECASPLATkLgYEBAQOCgoKCAhOB
AQMBASsjAauBC4IDAQUFgQEDAQErIwGrgQuCywEBAYEBAwEBqwMBq0MBAgEBAQGBAQMbgwFLq7uB
AQsLAwMDgQEDI0sBAQGrgQArgUuBAYEBgTNLCwOAI4ALAQHDAYsDAQEBKwGiAQFLAAUFyQEDCwMB
AQABqgELEwuBAQGMgQsDQwEBAQEBAVsLAwEBS0sAAUMBAQEBEwEBCwOZSwEjAYEBARMBAQEBAYsD
AQEBS0sDAQETAAEBAQEBG5qbnxszswEBmQFLCysDCwMBMQE5C4EBASMbm5u7AQsDgQEBADOzAQEp
gQGBiwMLAwGABAE5AQEBAQETywESAQEBe0tpCwEBAYEBAQELAQEBAQEBARMTCwEBgQEBAQETQ0MB
AUsBAQEBAQEDS4GBgQEBAQEBAQEBCwsBAwGBgYFLAYIDAQEBASMBK0tLggGCgoEBAQEBAQEjASsB
AQEBASMBAQErOwABS8sBAQEBqwGrAasjI0sBAQsxAykBAYEBgQGBAQEBCwJLExMBAQEBAQFLgQGB
gQEBI6s7AQEBywEBQwABAUMDQxsjAQDLG8MjywGaE0MBm4GBOwExAQFLIyMLAxMTAYEBAQOBC4u7
uwGNAwEBAAEBCzEBEwMxAIsZAQEBgYElJYsBAQEBAQEBAQEbIwEBAyurOQEBIyMBywHLMQEBASsB
AQEBAYEBk0sBAQGCAQATSxPLgQOBAQMBCwEAARuBIwGBEcBLgQGKAQsDBgQDAxEBE0sBAYEBAAuL
AQEBAQMbAQELAQGBASOBAQEBAQEBqzsZgQEBAQELnUudnR0BI7MzAQGBAQEBAQABATkjAQEDAQEx
AQEbI0M7K8ujQxMBAQABAYEbGyMBgQFLAQEDAQGDSwEbAxMBEwEAAQEBqwEGIyMjIwEjIyM7AwMA
AAMBAQMBqwEBAQEBEwEBAQEBIwEBohNLAQABAQEDAwEjBgYBAQFLAUsBARMrkwELAQsLCyMBgzkB
ARMBCwEDAbqBAQGBAQEBAxsBGwEBMQEBAQEDgYGKCQEBAaUBSyMBAQFLc4FLQzvLAQGlogEBORMB
AQEBASNLI0sBIwEBAQsBGwEBgSO7AQEBASMBAZsBAZMBAQwjMUOrjPojgYoDAYEjAHEDAwEBAasB
SwMBAQEBAAHzIwsBAYEBAUuhM8oBASsBAQMBAQEBaYlLq7CrAwEBiQAjSwEAAWEBEzuBAQEBAQEB
qxsBAQFRAQEAqyMBgQEBAYEBATkrWUsBARMBAUuBAYG7AwEBAQEBEwEjc3BzASOrqwEBAQEBAQEB
AYEBgQGBYgAAAAFLgQEBOwEBYwHLI+oFAQEBAwEB2gG5AwEBAAFBKSMBAQEDAQEjAwEASwABASEB
AQEBJisBS8IBAQEBASnBewF1ejmBgQGBAQEBipIBAQEzAQE5AUsrSwGBygEBgYGvAa8BAYEAAQAB
AQFhgaszswEBAQCBASUBHqMDOwGTIzsBjwGLAQErCU2BAwMBAcujAQEBizEAAQGBAUujMSMmAUsB
AYsBAQEAo6OjAQMDAQELAQEBARNJYYIDAQErA0MLgQE7EwGBCRupATsBAQEbAQEBASMBAQGBAaij
AAEBJgEBAQGAASlBAQF1i0sAARsmATsBQwEBAQsBMQFLo4EBAQEBccurK0sBAAEBS6OBARIBAQsB
qQGzASPKAwszgUurq6MBASMBEwCbAQEBgYE7i4oTAQEBARsLAQEBAQMAAAEBe4MBSyMBAYFLC0ED
C4EBEwGLExMBOQEBARMBAwEAAUsBAQGbASOBAZMBOY8AAYEBgTsBAVkbUQGrOwEBgQEBAQEDAQEA
gQABATsBAQEBAROBAQABgZsRAQEBAYE7AYGBigG7uwEBIwFLAQExeYt7AAF6STkBQxsBAQMBOQMT
AwEBSxMTUVgbAxsBAAEBgZsBAZYAAZsBAQEBAQEBAAEBSwEBAQMruQGBAQEBQ0urAQsBu4GLAQG7
AZoBqiMTigETAQExAQEDAQEBE4uLCwGBAQMBCIsBmwEBAAEAAQEBAUsbCwEBAQGBARMxAYE=`),
h:bload(`xgAD/gN+//9/fgMDA3/GAC8Df3lzcn8DfwKSAH5yLmotAgZxA37/8goCDv4yAgI2/n8HAnNyAlIv
Af8CAwP/LjEDc2qXf4R/f3IOA3MCFy4XFgdyAgcAAQJyDgI3DwByMwEBfgJFc2pycg5y1kUHBwAB
AXICRkcucn4OJgJGFxMCAwN+/5b//34CDv8DAi8AfwJrLrcCchsSAhJmfTJycgIDfgIXkX8DA38T
/38HAwcSAsX+3pfF/8b/A/4CfweSAAEAcAN/f38BFwZ/AgIC/gMCB3JycnJycnJycnJycnJycnKW
c3IAAwJ3cXUAAmoCc5MBAQEBAhIDAQEBAQJyBgPHE39+/5b/cpIWAwMXfgAAAAAS/wMCfwICVgMC
EjL/AgYC8nLyEn8DApJyEwISMhL/ApIOBgZ+AD41/n6SEwJyEwITfgMCc3+GfgMCfn4C/5MS/xOS
fn8CAn5//3+XpnMSE3K3E/4DAgB+A/9/f39+f/+XfwICDnKQfgJ2tv9+f/+XfzICAAAAAoa3ARKS
AgP/lv8CcgL3anIWA/5qcWr/A/+bf4ZyAi8BAnJy5fYCx/+Xf/9+AAd/EuXGA5IC5n8SFv4C/wID
AAECAfYCfgIC///W/n4CcgIyAjJ/9n6SATMzAn4DAwHXLQL+/wJ+Ai8RAmp/cnJyAn9/f39/fv4X
FuYDAn9+UwZyFw5/13NyNzbGA/5/flMmclcuBwIDfpeWxgICV15TJjJzkn9/An53dub/1pJyE2Zy
AzV+Un7y19bGc3J/flNScn5/F31yknNycrc2f34DBiJ+A35zAgcGAgICclYvA38NfnO3BgL+f34C
ApKSLwH/tn4XAxJzcn9+EpMDAwN/An5/fwJmFn4AAhIDAwMDfwMCf38GLwMuf/bGk39zAwMCAldf
AnIC//8exgN/fwMDagKSfwcHB4enZsaSBxNycmtyf38CAX7+H3LGApJ/t3cCAn9/FxICAKdmxpIG
cwJyBwZXXwJzc2rDAcYCAwN/hwJ+kgMCcv4CfwMDf3J/AgJ+Hl8CAnICA35zfwMDc3MDAwJ+khN/
f3IWVpZ21n7+chY2lv7+/v7+AgICfn4C/gIWNpZ/f35fcwICA38Df3J/kQIODhcDEwMCfgN/A38D
AwMDA38DAwN+BpKSc4cDAhN/FX8VfxUSM3IDA38CR8YCfxV/FX8VEjJ/f3///1dfcwNzA3MHc3Nz
cwMCB3Ny5n5zxn9yMeRyaH//h5d/xnFzc3IGcgJ+fjMDMXFwkwICcQNykeV/fpLmAnIBan9ykua3
ZgIRfgMC/gMDfwMDfkcCkQYFAtcCEjJzt7Z/AQICuwH+AgL/fgIC138FAwMCEjIRcgJxAnICcpJ/
AwN/AhcGcxcCAwJvAgB+c3+HFwZXRpICkgF/MTIyBQEXB4dql4YXAmYGc/6S/4cB7v8Dfndmfn/X
AgMCfn9+AwN/AwLXxi9xAv4DArdyc3IHEwOSf3J/cv5zc3G3aqdnf39zAgICA///c34GAwN/cwID
A3J/kmpqkhdyDn+SfpKScnN+f5FrcQL+l3L/fgOWtwN/f39yfxK3+wGScuZyBAQEBwAEBAVyJgYA
AP8DA5cXcX8CFwIBLgIXAX42lgMDLi8XAX4XAQI2NpdqJgYDAQKXApcDA30PBwMPAn5+f38DlwYD
A3d+fv/3An9zcwNzAgMDfy8CLQMBAwIDAn7+FnMXAgICf3IC/n/+AgL+flZyLg02kgJyLuZ+bpID
AwICk///Lw0CkgMDA38CkgMCNX8XAgICApIDAjMBAmZyAn1/A3IzcRr/cxd/13MsAAZ/BXNyAzEB
/gUCAwICAALWf33mfnLyRv4H1xID/5FGAn8BAgcCAif+MmIyBwFxJpMvLwF7AgLXfXJSAwIWfmoC
Ri8BAgICAgIARy4CUT5yApcBAXN8Av8CAi4DAn5xAhcWtwIDAv/m/wNzfwZ+ARYWNnICfQL/kgMC
/nJ9cv5yfgAAAJL+UX8CLwMA93IScn5v8wP+kwICfgFykQNV/gJGAgZyAwJ+AwN//5JxDXJyAQF+
fgEBt/4CkxICAgMCfn5yfgJyfgJycgNycgNyf3/3//+Xkn4CAn9rHmo3EgICc3MHfQYCAnL/ApJ9
AgICcre3Zn1+/v5yAh0CcQb//wJzkheWBn6WcgKSZ/9yfQ2SAzdytwEDdgP/AgJyff9yAnByAn8C
AdYDAwIAcnJxAuZ/AwN/AwJefn0CAn+3AgL//4Zp1wKSaQLARy3Gku8BkwMtf/J/AnIBAgLBAgcD
l1shcgHCAwIjwv/nfgJy8jeSSi1y8l6SXgHGAoYCAwL/cnEBfwMCAga3Z/8CAHMCf3JxAX4DAob/
5wFmAhcS/3+ncn7mkrUCcuaG1gDlfQICcgMKFg4SAwMDfn5+AQICAvJwAAIC/7YC/3ICARaXfgL/
/3Jqf38VEjIDfgOWfRYCE5J+An4CAgLlfuaWApUBAgYAATECci5eAgJ+/wJzcv4CEgECAwGOAgIA
cgACAi0DAgIDA5dxcl4BEjIGAmsAAnJ9l3FzDgJ2lgL+Bv5/AgIBkhb/fwJ+AgICfnICAn0Ct31+
frcB/hL//5KSfpICAH0DcgUClgb+AjMBkgKSAgJykQq3/gGSXv9y8pJykgMDfv/mcpKSMnLmfpIy
kn4CfgZ/f38VAnICAgPyAgMDFxIyfwNy/n8DZzN+MwED/wOb+wEDA5d/fgNzAvsxcn4AcnI=`),
j:bload(`gQAA9ACEgIABgoQAbxPIAEB0AIIAhgBgAIGAAIDChMDAgIKAAISAgICEhICIhICAgAQA9ACGgMBA
gICAAHSDiMAAgMDAgMACAICEiEH0AMAAwMDAgECAgIGAhIAAwICAQICAgIXAgMCAgISAgsDAQICA
gMCFwALAgICEwILAgIyAAHSAgICAgICEhIQA9EDgAIAAwoSClECChYTAoMLggoKAgIBAwAQCdAQC
9AQAYECCgICAgN2cgYGDjYCBBAD0AIAAgAB0BAD0TIMMg4iEgAD0wICAgICAgICAgICAgICAgICA
wMYAj4SCwoIAgMCAAICAgICAgIAAgICAgIyAgIRAdBiEgICAgODAAHQPgwAAAACcgAD0AICAwAD0
wMCAgMCCwIDAgAQA9ILgAPTAwICA4ICAgICAAMbAxuDgAPTAgICAgAD0dACDgAD0gICAgAD0gAD0
wACEgIAA9BwAhAD0APSAAPQAgICAAPQcAACDAPRcAICAgMCAgICAgICAAPRcAACAAAAAnMTAgODg
gAD0nICAgICAgoCAgICAgIOAAPQAAMCDgEDglMCPgICAAPQAAICAAAD0gICAAPTggACAjICAgICA
gIWBhYCBgIGEgICChICBhoTAgsAAgICEgEDAgICAgIBAwICAgIKAnED0gMEAg4CAnICAgICAgADE
woAPhACDQMCDQMOCgOKAxMKAD4MAg0DAg8DDAvQAjMTCgI+IQINAwNSDiAQC9ILEwoCAgICMQICD
AMOAyOPIxMKAgo4Ag0DAg4AcwICAgMTCgICAAINAgMCAb4QD9EDAgoCPgMBAdACCgACAgISAAICA
gISAQMCAgIDMj4aAxACAgM+EAG9EgoAAAPSAgIQAgoCPhAB0BALvAADAAGDAgIKAz4PIAOCEgEAC
9oCAgIDAgI+DiAB0w4CAgoCAgICAhIDPzIKCgACAAAD0gZeBg4yAj5wAgIDAiAAAwPbgAISEgM/A
AobGwMBAAvaAgMDBgoCPAHQEAO+AgIyAgICBBAB2RMBEgoKAxsaCgoCG4IODiAB0w8gA9ISDgICA
Y4zExMTExMSAjMDAwICAgICAjISEwMCcgIzAwMAcgIADgo6CAAB0DINAgIyAhMwPhgL0wgAAdAyD
j4QAdAQA7wCMwITgAAB0APZCwEDAQMCDg4wAYACBlMCCQsBAwEDAg4OAAIKCgMADj4+CigD0g4gO
YIOCgICAwIAAgETAwMDAwASAHHQAwICAAICAgIDAgEB0wM/AAO+FwI+EgICMj4CAgoCAwAD0hISA
gISAgoCMgABvBAFwgACBgMDAhICCg4OAgIADjIKAwICAj4CA4ISCAIDAiQDgg4PCgoKCgYCIwIAE
DHQAg0TCAICAAIDDiACEBAB0QINEwoCAgIBAwIDAgIDAA4yPRMKMj4KAgI+AgED0gIAAgETCgACA
hADvgECAAHQEAPREwkKAj4AA74CAAIDAgwzARMIAgOAA74CAgACAgIOMgI+DgACAwIGAAHQEQOAB
dIMAgICAgI+EgADAgoCAwICcQJyDgIiIgICAgICAhAB0BAyAAIKAwIDAgMCAgICAAICAgICAwMAA
AIAAdADAgAOMwICAwIDAgIDAgAB0wECAgIDAgICAgICAwMAA9JwAgAAAAICDzICDjICAhABgAMAQ
bwCDgICCgoCDjACDjABvBFDvwADvAe+QhJCAxADsgYGPFICEgAOAnICAgMSEwoCAgICAwMCAgIAA
YICGgICAQoCAgABvBBDggAD0xAQA9IKEgoCAgEDvkIjAj4AEAfRAgMCEAOwUzwLPAMCAwAPCAMCG
gMAAgIiAAICAgIDAgIDEwICAgICAQIDAhICAhgCMgcCAwInAQIDAwIBAdICIgIFAgITAgIDAg8CE
gkDvgJCBgIQAAsCAwMDAiMCAgEGAgYCAhMCAgIDMhECDgIAA9ICAhADgAMCAgIDAwIOAoIiAgADv
4IKghOCCgwAAAICAwAD0QHSAgIOAgIyAwICAgICEg4CNgBDAgIDAgYCAAPSAAHQAgMCAgIDAgIGA
g4CAgICAQPSAgACAgIGBgICAgIGDlxSDlxSDgICCgoyAg4OBjwBAgMCAgICAAICAgIDv4KCAgICA
iOCBoICAgICD4ICghIKEgICUj4AAgIDcgICDgJSAAICCgICAgICEwICAg4GAlOCCoICAgYCAgICA
gIOAD4AAhICAgIAEAG8EAPTAgICBgYCAjICAgISPgICEj4TPwMDAgICAgIDAgICDgIyAgITAgAB0
AMDAgIDAAICAwIGBgoiAgICPwMCAgMCAg4+MhICPAeCUgMCAwICAgYGAAICAAACCAIDAgIKAgIDA
wICAgICAgACAgICAgMCAhJzAgACAoIDvgkCDhMjgAHQEnICAgIiE4MCAAICEwYCAgMCAgMQAnIGA
gMDAdEDAg4OUgQDAgMCUAMCDgIyAgIKAjIDAgMCAgYAAgMCAgoCAgIGAgYQAgICAg4CPgICAhIAA
wACAhMGg4IwAYEDAgICAgJDAgEDvgMSAwIACxOCAgIKAgIAAgOCBw4CAAJaAgYGUgICAhJSPwYCA
gMCAgIKAgYGAg4SQAMAAgICEwICAhFDvgICAhODA4IDAgICAgICEwYCMgAB0gICAwICClIDUgoCA
gICA7IB0AEDAgIOJgADAgAB0QICAAACDgIcAb1CDQPQAgGAAwIAAdAQcgAB0gMDAg4CBgMA=`),
k:bload(`QgBAQMDgQEBAYEBAQEBEAERAQEBGxkBAQEBAAADgQEBAQPBBwOBAQlBASEBQQOBBQEBBQEXFQEpA
QEDgQEBCQkJAQEBEQEDAQENIQEBAUkBDQEBA4FBAQEBHSEBSSOBHQkBAQEBASEBBR0hE4EhQUEBA
QEBAQFBAQUBIUcBIQk1AQEBA4EBAQEBASEBAQEAAQEBAQEPgQ0BSQExCQENBRMDgwEBD4EDAQEDs
QEBEQEDwQENAQEBAQkVAQEBAQEJAAEAAQODAQEBAQVBAQEBAQEBAUEpKSkpKSkpKSkpKSkpKSkpE
QOAAQEDE4sQAQEBAQUBAQEBAQFpAQEBAQEBBWEBETOCDQEFAREDKQEBDQAAAAABMQEBAQEBAwkBA
SEBA4EDgQEDATEBAQOBATEDIwExAwMDIQ0NAAPDC4EBATEBATODM4EBAQkBEwEBAQOBAQEBMQExA
QEBAQMBAQEBE5ERMTEFDTEBAQEDAQEBA4MDgQEBCQIDgSENAwEBDQ0BAQEBCQKJAAAAAQEJDQExA
gEBAQkDgRABAQERBQEBAREBAQEBAQAJAQEBAQAJHQkdAREBAQMCiAExATEBBQEBAQUBJQEBAQEBA
QEBAQMdAREBAQEDgQEBA4EBCwEJAQERAQEFSQEFAQEBCQEBAQEBEQEBMQEBAQEFAQEBDQ0NDREDB
8UBAQMBASFBCSlDgQMNAyfFAQEDAQEhQQkJQxEBA4MHhQMBAyVBIUERCQsDAQODB4UBAQUAEQEJC
QELAUEBAweFA4ITAQEhQQkBAQkAEQEHhQ0NEwEBBUUlAwOBEQEhQwEBAAcBEQEDIQEBAREBAwEBA
QEBAQEJAQEBAQPBIQMBATEBAQEBA4EDAQEDBQkAAwOxAQEBAQMBAwEBAQEBAQOJA4EBBQEBAQMnw
wEFAQODIQMDgQEBAQEBAwEFBQUJCQUBAQvKEQEBCwEBAwEBAUERAQEBAQUFDQMBAQPBAAEBAQOBS
48DjQFDA8MBAQEBBYEDAQEBAQgBCQEBAQUBAQEDAQEBA4OBA8PDA4ETA4EDgQEBAQEFAQEDg4OzA
QARASEBAQEBABEBIQICAgICAQEBAQEBAQEDAyMBAwMRQ4NjgQEBAQARARECrq0BA8MBA4EBAQEBA
QEBAQEBAQEBAREBAREJAAPDAQEBAQEBQUARAQEBAUEJAwEBAQEBAUFDgwODA4MlQQEDB4EBEQELA
QkDgQkBBQEBCBEBBREDjQEBAQEBAQEJBRERCQUDCoERAQUJAQEBAQUBEQELAQEBBwONAQEADQEBD
QEBb4EBAQEBAQEBAQFAAQEBAQEDAUFBCQkBAQMBAQEBAQEBAQEDgQEBAQEBAUFDwwcDBwERAREBA
QEBAQEDxQUFAQABAQABAREBCQPFI8UBAQEBAQUFDUkBBUELAQOFAQEJEQEBAQEBAQEDgwEDhQEBA
QEBAQEBAQEBAQEBA4UBBQEBAQEJCQEFJUEBAQOFAAUBBQUNCQEDgwEBBQEBAQEBA48BCQEBAQgBA
QEBAQEBAQEFBSEBA4EBAQeRAQEBAQUBAQkJAQEBAQuBAwEBCQElCQEBAQEBAUlJSUkBSUlJBTEQA
AEBAQEBIQUBASEBAQEBIQMBIQEBAQEBBQEBIQEBAQEJATERAQEBAQEBA4MBQQUBQQEBAwEBAQEBA
QEFAwEDgwENCQUBAQEBAQEBAQEBAQEBAQEBASkBAQEBAQEBAQEBAQEBAQEJAQEhBQABAQEBAQABA
QODAQEBAQEhAQEBAQEBAQEBAQkBDQMBAwEBAQEFAQEBBQEBAQEFCQEBAQEBAQEFAAFdAQELBQELA
QEAAQEBAAEBAwEBAQENCQEBEQ0xAQEBIQEBAwFJAQEBAQkBCUEBASEBAQEBAQEBBQEFKQEBXQEBA
UkBAQEBAQEAAUkBASlBCQEFAQEHgQEBAQEBAQEBBQEBDQEBAQEBAQEBEQEdAQEDCykJAQEBAQEBA
QERAQEBERgAAAEBASEBAQEBARkVMREZIQEBAQEBARUBFQEBIQEBKQEJCQEBAQEBAQEBCSERCQEBA
QEBAQkBAQExAQEBAwEBFQEBDR0BCQUBAQUBAREDhwEBDQEBAQEBASEBETEBAQkJCQEJAQERAQEBA
QEBAREJDQkBAQEBEQHhAQUFAQEBBQEhDQEBAQUBAQEDkQEhAQENDQ0BAQEBAQEBEQEBDQERCQEBA
QEBAQEAAQUFBQEBAQEBAQEBAQEBAQEBAQOBAQEBAQ0BAQEBCSUBAQEBAQOBAwEBAQERA4EBCQEJK
QEhKQkBEQEBKREBEQEBDR0RASEBCQMBAUEBAQEdAQEBAQ0BAQEBAQERCQkDgAEDAQEFAQOFAQEBA
QEBAQEhM4EBAQEBCQkNAQUJB4QBBQEBARENIQEtRQEBAQEDAQEBAQEBCAEBAQEdAQERAQMBA4EBA
QEJAQEBAUVFAQEBA4MFASEBAwEBAQEBBQEJAQEBAQEAAQENAZEBAQGBAQEBAQUBAUkBAQEBAQEAA
QgBAQEBAQEBAQEJBQUBAUkFCQEBAQEBAQUFES0BDQ0BAQkBAQEBAQFBAQMBDQEBAAEQAQEBAQEBA
QEBAQFFAQGBAQEBAAEBAREFAQEFAQEFAQMBAQEBBQEhAQEBAQEBAQkBCQEBAQEBCQEDgQ0FA4EDj
QMNAwULAQEBBQEBAQEBAQEBAQVBQQEBAQEBAQEBAQUBAQEBAQEBAQEDgwEBCAEBDQOBAQkI=`),
l:bload(`GAD+HvwY+Pj/GZn+//8cAP7//5j8G/7//xgeABAbGKCYHB2Y/Br4Fh0HeAAXHBwVHPn+GPwbHrj/
mPgc/f/4GJj/maD4+Bn8/x4Z+P2g/xj/GJigH/8RmB4YHRj/+B2g/5iYGRmYmaAcGB0ZGJj4/xGY
mKAZGP8dHBkdGR0Y+PgY/v8f+Br4+BgdHPj+GP0Y/xD/HfgZEP8cHxwcmKAeHhj4HBj/mP/+//n+
+Pn+//8aEJgQEPiY+Bn4mB8Z+f4YAJgAGf7//v6Y/Bj8GBgdGP4Y+BISEhISEhISEhISEhISEhIY
+BsA+ByQmJAAgBiA//mQkJCQGKH/kJCQmBgYofD+//xZ+Br4Hxkb/v//HQAAAAAf+P4b/B+4G/4b
Gxv4Gxu4GxsZG/7+GR0b/hsbGxn4GxsbGxsZABuYGxsZ/htT+Fv4W/4b/PwaGP4bGh+4+P5bmP5b
HP+5ARj++Pz7HP5b/lv4/lv+HIAY/vj8/Pob/vj8/x0UFRiAGLi4uPgb/vj8/xm4AAAAGQD4mBkZ
Xf74HPgaERH4GRV++B0dmB34/vj//B8YoP2YHR4ZmKC4/vj8//gfAP74Hpgc/hkfHPwZGRgW+Bj4
gJgemKAZeRkc+PgYfxkeGRygGaD/HHkYmP+YoBn4mJj/mB4d+Bh5Gf2YGaD/HR8dGZiYmJiYeXz4
Gxv/HPwa/xoa+Br4+Pga+Bsb/x38Gv8aGvga/hr5GvgbGxob/Br/Ghv4oP/+Ghz4Gxv4Gxka/6Aa
+JgaGhoa+Bsb+Br8G/8aGhz8+JgYGfgbFPh5/Bv/GhB8/x/+GP+guBoaGhv+//mYHP/4Ghp6/xwa
GRsZ/5j4Gnz4+BqYGv8cGfj4/v//uBn7/hscGxoAuB/4+P7///4b+/4b/v8a+BsZ+Pj4/vi4oPv+
GxkU+PgaGfj4+P7/GqAa+Pj4+Pj4Ghka+PgaEP8a+/4bmBt6+BoZGhD/+PgaoPv++BsZAPgZGRoT
/7gb+KD7/hv4+Rj4mBka/v///hwHGvgZHx8a/v7//hv+uLhZG/i4uB24+Bv4+P7/+Pj++BkbG/j4
/xobGxsbGxsTGhsbGyMjIyMjGxsbGxsbExsaGhr8+Fv8+Bu4/v7//Br8mBsaGvj/+P4bG/7+//z4
+Pj+///++P8bFBsZ/v7/HPj8mPyY/Jgb+Br+//8S+BsZ/Jj8mPyYGxv4//j4+Pj/+Pj4+P34+Pj9
//gZ+PgTFBT/Gv8amBscG/74/v/8FJj4/6AbExsbGv3/mJgb/hsbmPgamJj4GxoauAOYG/5cGxv4
GBuYG5gbG/7///7/Ev8amBiYuPgZGhr4+KD/mLgZ+JgZWhn4ERkZ/PiY+P4ZoKCYGxmYGqAaAh3+
/v/8G/8b//gc+BD4oAAb/v7//Bv/GxwcHJj/mAQfmJjg/Pga/xv4HBwc+Bwc+P6YBPj8Hv8bHPyY
Gf4fGv8b/v/+/hz/G/+YHRj+GfhZ/xz4+P+g/xv+HR7+mJj4Wf/4+Pj4GR4c+P/4+Bsc/v///hL+
/xv/EBAaFPgQHPygHBsZG/gc/5j4mBwd+F34HPkc4P7//v4Z/B34+JigHBwUFBQU/xQUFJgdHBwA
APj+///4mP8bmByYHRz4mBwdHf3/HP/4mBz4kB+goPhdoKD+mBz/HP/8/Jj4+Pj4oByg+P7//x/+
//4eG/j4oPj4+P/4oP7///4dmP2Y/R/4GBkfGv6YGRkcmRMdHP8UHxsaHRoYHpgVFRgTHBQUFBj9
/xy4+Pj4/5igHf7///4dHf4amPn+HbgduB34Hf2YHR0dHZj5/h3/mBr4/vj5+P8YABj4mP8d/5iY
HpgemB24ALgd+JgUFBQcGh6Y+B34/5gaHfiYuP8dGZgeoBmg/5CYHZj9/5iYGRn/mBgd+BgdHaAc
GP2YGR0ZGBwA/x0ZmB2gGfiYmP8dGfgdGRn4GBiYHf8dmBz+Hfgf+P7//x0dmH0YGBgZmB34H/4Z
GR6YG30eHQAAABQdmP4c/f+Y+B0dGB34+PgYmBkcHZigmP+YGxkeHRwd/h0f/v/8+BSYmBh4mJgZ
HpiY+B4e/hEZHv4eHgcRFREQGBkWFv8WFv8W+Pj4+Pj4Hh4eF///Fx/4HRYe//iYmB4fHB74GBiY
Hx4ZHvj4HpgbFngeGZgZmB/4+B7/HZh+Hh4dHh8d//gUmJgZ+PgQ+JigHfj4GBkemPgWHh8eHPgd
mB35/x4AEBWYHR35/v///h0eHpgWHviYoB74+BaY+B4WmBYe+JgeHpiY+JiYmB6YHh6YoBaYHv7/
//iYHpig/h74oOD4Hx4QHvgVFpgeHh4eHpgeHh4e+KD4FpiY+PgdFh74//geAP8e/xaYmBj4Hh74
+JgZGfgd+P/5HxYeHpgfHhEeHwCYmB4dHv8fBxYf/v/+Hx8emB8fHhQfAB64+B4f+BYemBr+HxT4
mB8H//yYHx/4Gf8fmB8e/KAfBx4fHxmYGhEeH5iYHh4AmJgfHh8fHR8fgBj/HRYZH5gf+JgcHx0A
HwAdF5j4Hx/+//+QHx+YHAAfoP2YHxqQ+JD/Fh+goB+gH6D8GB+fHx+Y/6AVHgegHx8fGJgY+JgH
HPiYBx/44B4fHx8fAJj/HpgZHx8YGf2YGR8ZHBkdmBmYH5gUH/gXHxkfGf7/H/gWHx8fGB+gGRkf
GR8dHR///P+YHwcVBfwUH/7//B8f/v8fGPj+//8Y/Zj++P//+Jj+//7+H/7/GfiYGB8fHxk=`),
m:bload(`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`),
map:bload(`iwEZT4uLha97k4uOyn6Li/39/Pz7+/r6Vvn+7t7Ougfv7+/v7+/v7x0eIiMkIYuL+Pj4+Pj4+Pgu
LyolTU4fH0VFRUVFRUugQUFBQEBAQECJiYmJiYl8fUNDQ0BAQEBAFGVlZWVlt7AxZGRkZGRQUwlU
VFRUVIuJiWRkZGRkkJAbUVFRUVGLPTM1NTU1NTU1FVRUVFRUiwkzNTU1NTU1NStRUVFRUYsJMzU1
NTU1NTU8VFRUVFSLCTM1NTU1NTU1LGBgYGBgiwk0NjY2NjY2Nj5iYmJiYmuLNDY2NjY2NjYmYGBg
YGCLCTQ2NjY2NjY2MGJiYmJiixM0NjY2NjY2Ng==`)
};

const disk_images:{main:ArrayBuffer|null, main_view:DataView|null} = {
	main: null,
	main_view: null
};
this.document.body.addEventListener('dragstart', function(ev) {
	const dt = ev.dataTransfer;
	if(dt) {
		dt.dropEffect = 'copy';
	}
	ev.preventDefault();
});
this.document.body.addEventListener('dragover', function(ev) {
	const dt = ev.dataTransfer;
	if(dt) {
		dt.dropEffect = 'copy';
	}
	ev.preventDefault();
})
this.document.body.addEventListener('drop', function(ev) {
	const dt = ev.dataTransfer;
	do {
		if (dt == null) break;
		if (dt.files.length < 1) break;
		if (dt.files[0].name.match(/\.[iI][mM][gG]$/) == null) break;
		dt.files[0].arrayBuffer().then(function(buf) {
			disk_images.main = buf;
			disk_images.main_view = new DataView(buf);
			console.log('loaded disk image');
		});
	} while(false);
	//console.log('drop!', ev.dataTransfer);
	ev.preventDefault();
})

const vt_width = 8;
const vt_height = 10;
const vt_font_data = new ImageData(128, 128);
(()=>{
	const vtf = new Uint32Array(vt_font_data.data.buffer);
	for(let y = 0; y < 64; y++) {
		const line0 = (y) * 128;
		//const line0 = (y << 1) * 128;
		//const line1 = ((y << 1) + 1) * 128;
		const vtline = y * 16;
		for(let x = 0; x < 128; x++) {
			let bs = (x & 7);
			let v = (vtfont[vtline + (x >> 3)] >> bs) & 1;
			// #66aaf0
			if (v > 0) {
				vtf[line0 + x] = 0xcff0aa66;
				//vtf[line1 + x] = 0xcff0aa66;
				if (bs > 0) {
					vtf[line0 + x - 1] |= 0x4ff0aa66;
					//vtf[line1 + x - 1] |= 0x7cf0aa66;
				}
				if (bs < 7) {
					vtf[line0 + x + 1] |= 0x4ff0aa66;
					//vtf[line1 + x + 1] |= 0x7cf0aa66;
				}
			}
		}
	}
})();
const vt_font_bmp:ImageBitmap = await createImageBitmap(vt_font_data);
class VTerm {
	buffer = new Uint8Array(80*24);
	blink = false;
	cursor_x = 0;
	cursor_y = 0;
	ctx:CanvasRenderingContext2D;
	static columns = 80;
	static rows = 24;
	static char_base = 0;
	input_buf:number[] = [];
	mux:MUXPort | null = null;
	constructor(c:CanvasRenderingContext2D) {
		this.ctx = c;
	}
	update_blink() {
		const vcx = this.cursor_x * vt_width;
		const vcy = this.cursor_y * vt_height;
		const vca = this.cursor_y * VTerm.columns + this.cursor_x;
		let vcc = this.buffer[vca];
		
		this.ctx.clearRect(vcx, vcy, vt_width, vt_height);
		if (this.blink) {
			this.ctx.fillRect(vcx, vcy, vt_width, vt_height);
		} else if (vcc > 32) {
			//this.ctx.strokeText(this.chardec(vcc), vcx, vcy + VTerm.char_base);
			vcc = vcc - 32;
			this.ctx.drawImage(vt_font_bmp, (vcc & 15) * vt_width, (vcc >> 4) * vt_height, vt_width, vt_height, vcx, vcy, vt_width, vt_height);
		}
		this.blink = !this.blink;
	}
	chardec(c:number):number {
		if ((c < 32) || (c > 127)) return 0;
		return c - 32;
	}
	scroll() {
		this.ctx.clearRect(0, 0, cv_term0.width, cv_term0.height);
		for(let r = 1; r < VTerm.rows; r++) {
			const vcy = (r - 1) * vt_height;
			const vcb = r * VTerm.columns;
			for(let col = 0; col < VTerm.columns; col++) {
				const vca = (r - 1) * VTerm.columns + col;
				const vcx = col * vt_width;
				let vcc = this.buffer[vca] = this.buffer[vcb + col];
				vcc = this.chardec(this.buffer[vca]);
				this.ctx.drawImage(vt_font_bmp, (vcc & 15) * vt_width, (vcc >> 4) * vt_height, vt_width, vt_height, vcx, vcy, vt_width, vt_height);
			}
		}
		for(let vcx = 0; vcx < VTerm.columns; vcx++) {
			const vca = (VTerm.rows - 1) * VTerm.columns + vcx;
			this.buffer[vca] = 32;
		}
	}
	advance_line() {
		this.cursor_y++;
		if (this.cursor_y >= VTerm.rows) {
			this.cursor_y = VTerm.rows - 1;
			this.scroll();
		}
	}
	write(c:number) {
		const vcx = this.cursor_x * vt_width;
		const vcy = this.cursor_y * vt_height;
		const vca = this.cursor_y * VTerm.columns + this.cursor_x;
		c = c & 255;
		let vcc:number = 0;
		if (c < 32) {
			if (c == 10) { // LF
				this.advance_line();
			} else if (c == 12) { // FF (clear)
				this.cursor_x = 0;
				this.cursor_y = 0;
				this.ctx.clearRect(0, 0, cv_term0.width, cv_term0.height);
				let limit = VTerm.columns * VTerm.rows;
				for (let q = 0; q < limit; q++) {
					this.buffer[q] = 32;
				}
				return;
			} else if (c == 13) { // CR
				this.cursor_x = 0;
			} else {
				this.write(94);
				this.write(64+c);
				return;
			}
			this.ctx.clearRect(vcx, vcy, vt_width, vt_height);
			vcc = this.chardec(this.buffer[vca]);
			this.ctx.drawImage(vt_font_bmp, (vcc & 15) * vt_width, (vcc >> 4) * vt_height, vt_width, vt_height, vcx, vcy, vt_width, vt_height);
			return;
		}
		vcc = this.buffer[vca] = c & 255;
		this.ctx.clearRect(vcx, vcy, vt_width, vt_height);
		vcc = this.chardec(vcc);
		this.ctx.drawImage(vt_font_bmp, (vcc & 15) * vt_width, (vcc >> 4) * vt_height, vt_width, vt_height, vcx, vcy, vt_width, vt_height);
		this.cursor_x++;
		if (this.cursor_x >= VTerm.columns) {
			this.cursor_x = 0;
			this.advance_line();
		}
	}
	receive(c:number) {
		if (this.input_buf.length < 8)
			this.input_buf.push(c);
		if (this.mux != null) {
			this.mux.receive();
		}
	}
}
const cx_crt0 = new VTerm(cx_term0);
setInterval(function(){ cx_crt0.update_blink(); }, 500);
cv_term0.addEventListener('keypress', function(ev) {
	ev.preventDefault();
});
cv_term0.addEventListener('keydown', function(ev) {
	//console.log(ev.key.toUpperCase().charCodeAt(0));
	if (ev.key.length == 1) {
		//cx_crt0.write(ev.key.toUpperCase().charCodeAt(0));
		cx_crt0.receive(ev.key.toUpperCase().charCodeAt(0));
	} else switch(ev.key) {
	case 'Enter':
		cx_crt0.receive(13);
		break;
	case 'Escape':
		cx_crt0.receive(27);
		break;
	}
	ev.preventDefault();
});
cv_term0.addEventListener('keyup', function(ev) {
	ev.preventDefault();
});
(()=>{
	for(let c of 'Centurion VI Simulator 2022') {
		cx_crt0.write(c.charCodeAt(0));
	}
})();

const init_program = '79 86 23 C8 E5 EC EC EF F2 EC E4 A1 8D 8A 00 71 80 01';
const program_rotl = '60 AA AA 60 AA AA 55 40 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 37 00 71 01 03';
const program_rotr = '60 AA AA 60 AA AA 55 40 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 36 00 71 01 03';
let HEX_CONV = false;

function hexlist(v:number, l:number = 2) {
	const pre = HEX_CONV ? '0x' : '';
	if(v < 0) return '-'+ pre + ((-v).toString(16).toUpperCase().padStart(l,'0'));
	return pre + v.toString(16).toUpperCase().padStart(l,'0');
}
function hex(v:number, l:number = 2) {
	if(v < 0) return '-'+ ((-v).toString(16).toUpperCase().padStart(l,'0'));
	return v.toString(16).toUpperCase().padStart(l,'0');
}
function bin(v:number, l:number) {
	return v.toString(2).padStart(l,'0');
}
function sbyte(v:number):number {
	v = v & 0xff;
	if (v > 127) v -= 256;
	return v;
}
function nyb(c:number):string {
	return (c >> 4).toString(2).padStart(4,'0') + ' ' + (c&15).toString(2).padStart(4,'0');
}
function bit(v:number, b:number):number {
	return (v >> b) & 1;
}

const ALU_RN = ['0','D','A','B','Q'];
const ALU_FN = ['+','-','|','&','^'];
const ALU_S = [[2,4],[2,3],[0,4],[0,3],[0,2],[1,2],[1,4],[1,0]];
const ALU_F:{on:number,ivr:boolean,ivs:boolean}[] = [
	{on:0,ivr:false,ivs:false},
	{on:1,ivr:true,ivs:false},
	{on:1,ivr:false,ivs:true},
	{on:2,ivr:false,ivs:false},
	{on:3,ivr:false,ivs:false},
	{on:3,ivr:true,ivs:false},
	{on:4,ivr:false,ivs:false},
	{on:4,ivr:true,ivs:false}
]
const ALU_D = [
	'      Q=  F=',
	'          F=',
	'F=A B=  ',
	'      B=F=',
	'srbQ  B=F=',
	'srb   B=F=',
	'slbQ  B=F=',
	'slb   B=F='
];

class ALU {
	src:number = 0;
	aop:number = 0;
	dst:number = 0;
	sel_a:number = 0;
	sel_b:number = 0;
	in_data:number = 0;
	reg:number[] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
	regq:number = 0;
	y:number = 0;
	out_f:number = 0;
	carry_in:number = 0;
	carry_out:number = 0;
	sign:number = 0;
	over:number = 0;
	zero:number = 0;
	ram0:number = 0;
	ram3:number = 0;
	q0:number = 0;
	q3:number = 0;
	is_shift:boolean = false;
	is_right:boolean = false;

	// save results to register(s)
	step() {
		const dst = this.dst & 7;
		const ib = this.sel_b&15;
		switch(dst) {
		case 0: this.regq = this.y; break; // Q=
		case 1: break; // nop
		case 2: this.reg[ib] = this.y; break; // B=
		case 3: this.reg[ib] = this.y; break; // B=
		case 4: // B=F>>1 Q>>=1
			this.reg[ib] = (this.y >> 1) | (this.ram3 << 3);
			this.regq = (this.regq >> 1) | (this.q3 << 3);
			break;
		case 5: // B=F>>1
			this.reg[ib] = (this.y >> 1) | (this.ram3 << 3);
			break;
		case 6: // B=F<<1 Q<<=1
			this.reg[ib] = ((this.y << 1) | this.ram0) & 15;
			this.regq = ((this.regq << 1) | this.q0) & 15;
			break;
		case 7: // B=F<<1
			this.reg[ib] = ((this.y << 1) | this.ram0) & 15;
			break;
		}
	}
	// perform logic flow
	resolve() {
		const src = ALU_S[this.src & 7];
		const dsti = this.dst & 7;
		const fn = ALU_F[this.aop & 7];
		const ia = this.sel_a&15;
		const ib = this.sel_b&15;
		// TODO fn.iv
		const vals = [0, this.in_data, this.reg[ia], this.reg[ib], this.regq];
		let val_r = vals[src[0]];
		let val_s = vals[src[1]];
		val_r = (fn.ivr ? ~val_r : val_r) & 15;
		val_s = (fn.ivs ? ~val_s : val_s) & 15;
		let out = 0;
		switch(fn.on) { // [+ - & | ⊻]
		case 0:
		case 1:
			out = val_r + val_s + this.carry_in;
			this.carry_out = Number(out > 15);
			this.over = this.carry_out ^ Number(((val_r & 7) + (val_s & 7) + this.carry_in) > 7);
			break;
		case 2:
			out = val_r | val_s;
			this.over = this.carry_out = (Number((val_r|val_s)==15) ^ 1) | this.carry_in;
			break;
		case 3:
			out = val_r & val_s;
			this.over = this.carry_out = Number((val_r&val_s)!=0) | this.carry_in;
			break;
		case 4:
			out = val_r ^ val_s;
			break;
		}
		this.y = out & 15;
		this.zero = this.y == 0 ? 1 : 0;
		this.sign = this.y > 7 ? 1 : 0;
		if (dsti == 2) {
			this.out_f = vals[2] & 15; // select A to the bus output
		} else {
			this.out_f = this.y;
		}
		this.is_shift = dsti > 3;
		this.is_right = (dsti & 2) == 0;
		if(this.is_shift) {
			if(this.is_right) {
				this.q0 = this.regq & 1;
				this.ram0 = this.y & 1;
			} else {
				this.q3 = (this.regq >> 3) & 1;
				this.ram3 = (this.y >> 3) & 1;
			}
		}
	}
	// debug/trace string
	funcstr() {
		const srci = this.src & 7;
		const fni = this.aop & 7;
		const dsti = this.dst & 7;
		const src = ALU_S[srci];
		const fn = ALU_F[fni];
		const dst = ALU_D[dsti];
		const ia = this.sel_a&15;
		const ib = this.sel_b&15;
		let r = `(sfd:${srci}${fni}${dsti})${dst}${fn.ivr?'~':' '}${ALU_RN[src[0]]}${ALU_FN[fn.on]}${fn.ivs?'~':' '}${ALU_RN[src[1]]}`;
		return r.replace(/[ABb]/g,ss=>{if(ss=='b')return'B';return ss=='A'? `[${hex(ia,1)}]`:`[${hex(ib,1)}]`;});
	}
}
const FN_E6 = [
	'','F=>Result','F=>RIdx','F=>Level',
	'F=>PTA','ASwap','SEQ_RE','(!)CondRegLD'
];
const FN_SEQ_SN = ['uPC','AHR','STK','DIR'];
const FN_SEQ_FE = ['POP','PSH','---','---'];

function mcdump() {
	// TODO rewrite
}
class Sequencer {
	p:number = 0;
	h:number = 0;
	sf:[number,number,number,number] = [0,0,0,0];
	sp:number = 0;
	output:number = 0;
	reset() {
		this.p = 0;
		this.h = 0;
		this.sf[0] = 0;
		this.sf[1] = 0;
		this.sf[2] = 0;
		this.sf[3] = 0;
		this.sp = 0;
		this.output = 0;
	}
	step(cin:boolean, sel_s:number, fc:number, d:number, or:number, zero:boolean):boolean {
		let c = false;
		let out = 0;
		switch(sel_s & 3) {
		case 0: out = this.p; break;
		case 1: out = this.h; break;
		case 2: out = this.sf[this.sp]; break;
		case 3: out = d; break;
		}
		out = zero ? 0 : (out | or) & 15;
		if (fc == 0) this.sp = (this.sp + 1) & 3;
		if (fc == 1) this.sp = (this.sp - 1) & 3;
		this.output = out;
		if (cin) {
			out = out + 1;
			if (out > 15) {
				out = 0;
				c = true;
			}
		}
		if (fc == 1) this.sf[this.sp] = this.p;
		this.p = out;
		return c;
	}
}
function seqencer_selftest() {
	function seqencer_initial() {
		const v = new Sequencer();
		v.p = 2;
		v.output = 0;
		v.h = 4;
		v.sf[0] = 6;
		v.sf[1] = 8;
		v.sf[2] = 10;
		v.sf[3] = 12;
		return v;
	}
	function seqencer_display(v:Sequencer) {
		const ilu = ['Z','Z+1','J','J+1','K','K+1','Ra','Ra+1','Rb','Rb+1','Rc','Rc+1','Rd','Rd+1','D','D+1'];
		console.log('seq', 'pc',ilu[v.p], 'h',ilu[v.h], 'stk0', ilu[v.sf[v.sp]], 'stk1', ilu[v.sf[(v.sp + 1) & 3]], 'stk2', ilu[v.sf[(v.sp + 2) & 3]], 'stk3', ilu[v.sf[(v.sp + 3) & 3]], 'out', ilu[v.output]);
	}
	let test = seqencer_initial();
	test.step(true, 0, 0, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 0, 1, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 0, 2, 14, 0, false);
	seqencer_display(test);

	test = seqencer_initial();
	test.step(true, 1, 0, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 1, 1, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 1, 2, 14, 0, false);
	seqencer_display(test);

	test = seqencer_initial();
	test.step(true, 2, 0, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 2, 1, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 2, 2, 14, 0, false);
	seqencer_display(test);

	test = seqencer_initial();
	test.step(true, 3, 0, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 3, 1, 14, 0, false);
	seqencer_display(test);
	test = seqencer_initial();
	test.step(true, 3, 2, 14, 0, false);
	seqencer_display(test);
}
seqencer_selftest();

interface BPLDev {
	dev: MemAccessR,
	devw?: MemAccessW,
	base: number,
}
class Backplane implements MemAccessR, MemAccessW {
	decode_hi:BPLDev[] = [];
	decode_io:IOAccess[] = [];
	is_write:true = true;
	constructor() {
	}
	configio(id:number, m:IOAccess) {
		this.decode_io[id] = m;
	}
	configmemory(base:number, m:MemAccessR | MemAccessW & MemAccessR, sz:number = 256) {
		let aval = base & -256;
		let atarget = aval + sz; // TODO
		let dev:BPLDev = {
			dev: m,
			base: aval,
		};
		if (m.is_write) {
			dev.devw = m as MemAccessW;
		}
		while (aval < atarget) {
			let aindex = aval >> 8;
			if (this.decode_hi[aindex]) {
				//throw new Error('backplane overlap');
			}
			this.decode_hi[aindex] = dev;
			aval += 256;
		}
	}
	is_interrupt(cpl:number):boolean {
		for(let i = 0; this.decode_io[i] != null; i++) {
			let dev = this.decode_io[i];
			if (dev.is_interrupt() && (dev.getlevel() > cpl)) return true;
		}
		return false;
	}
	ack_interrupt(cpl:number):number {
		for(let i = 0; this.decode_io[i] != null; i++) {
			let dev = this.decode_io[i];
			if (dev.is_interrupt() && (dev.getlevel() > cpl)) {
				dev.acknowledge();
				return dev.getlevel();
			}
		}
		return 0;
	}
	reset() {
		for (let dev of this.decode_io) {
			dev.reset();
		}
	}
	is_mmio(address:number):boolean {
		let aindex = address >> 8;
		let dev = this.decode_hi[aindex];
		if(dev) {
			return dev.dev.is_io == true;
		} else {
			return true;
		}
	}
	readbyte(address:number):number {
		let aindex = address >> 8;
		let dev = this.decode_hi[aindex];
		if(dev) {
			let v = dev.dev.readbyte(address - dev.base);
			return v;
		}
		return 0x00;
	}
	writebyte(address:number, value:number):void {
		let aindex = address >> 8;
		let dev = this.decode_hi[aindex];
		if(dev && dev.devw) {
			dev.devw.writebyte(address - dev.base, value);
			if ((address >= dis_vpc) && (address < dis_vpc_end)) {
				dis_after = true;
			}
		}
	}
}
const bpl = new Backplane();
type DMAFunc = (atend:boolean, ctrl:DMAControl)=>void;
let sense_switch = 0;

class MCState {
	s0 = new Sequencer();
	s1 = new Sequencer();
	s2 = new Sequencer();
	alul= new ALU();
	aluh= new ALU();
	alu_flag = 0;
	ccr = 0;
	file = new Uint8Array(256);
	page = new Uint8Array(256);
	workaddr = 0;
	memaddr = 0;
	memdata_in = 0;
	memdata_out = 0;
	resetting = 1;
	physaddr = 0;
	physpre = 0;
	busctl = 0;
	sysctl = 0;
	sys_write_latch = false;
	cycles = 0;
	rtc = false;
	f12a = 0;
	f12b = 0;
	b15a = 1;
	dma_12 = 0;
	dma_13 = 0;
	dma_func:null|DMAFunc = null;
	swap = 0;
	result = 0;
	level = 0;
	reqlevel = 0;
	rir = 0;
	rdr = 0;
	pta = 0;
	override_or = 0;
};
const mcstate = new MCState();

function mcreset() {
	mcstate.s0.reset();
	mcstate.s1.reset();
	mcstate.s2.reset();
	mcstate.result = 0;
	mcstate.swap = 0;
	mcstate.level = 0;
	mcstate.sysctl = 0;
	mcstate.busctl = 0;
	mcstate.resetting = 1;
	mcstate.sys_write_latch = false;
	mcstate.dma_12 = 0;
	mcstate.dma_13 = 0;
	mcstate.cycles = 0;
	bpl.reset();
}

const enum CCR {
	CARRY = 1, L = 1, BIT_L = 0,
	OVER = 2, F = 2, BIT_F = 1,
	SIGN = 4, M = 4, BIT_M = 2,
	ZERO = 8, V = 8, BIT_V = 3,
};

function mcshowstate() {
	let mcp = mcstate.s2.output.toString(16) + mcstate.s1.output.toString(16) + mcstate.s0.output.toString(16);
	let mpc = mcstate.s2.p.toString(16) + mcstate.s1.p.toString(16) + mcstate.s0.p.toString(16);
	let mhr = mcstate.s2.h.toString(16) + mcstate.s1.h.toString(16) + mcstate.s0.h.toString(16);
	let mstk = '';
	let msp0 = mcstate.s0.sp, msp1 = mcstate.s1.sp, msp2 = mcstate.s2.sp;
	let fl = mcstate.alu_flag;
	let malu1 = hex((mcstate.aluh.regq << 4) | mcstate.alul.regq, 2) +
	` ${hex(fl,2)} ${(fl&0x20)!=0?'L':'-'}${(fl&0x10)!=0?'H':'-'}${(fl&8)!=0?'C':'-'}${(fl&4)!=0?'V':'-'}${(fl&2)!=0?'S':'-'}${(fl&1)!=0?'Z':'-'}`;
	let malu2 = '';
	let malu3 = '';
	for(let i=0;i<4;i++) {
		mstk += mcstate.s2.sf[msp2].toString(16) + mcstate.s1.sf[msp1].toString(16) + mcstate.s0.sf[msp0].toString(16) + ' ';
		msp0 = (msp0 - 1) & 3;
		msp1 = (msp1 - 1) & 3;
		msp2 = (msp2 - 1) & 3;
	}
	for(let i=0;i<8;i++) {
		malu2 += hex((mcstate.aluh.reg[i] << 4) | mcstate.alul.reg[i], 2) + ' ';
		malu3 += hex((mcstate.aluh.reg[i+8] << 4) | mcstate.alul.reg[i+8], 2) + ' ';
	}
	
	for(let rindex = 0;rindex < 256;rindex += 32) {
		let rfilel = '';
		let rfiler = '';
		for(let i=0;i<16;i+=2) {
			let reg = (mcstate.file[rindex + i] << 8) | mcstate.file[rindex + i+1];
			let regr = (mcstate.file[rindex+16 + i] << 8) | mcstate.file[rindex+16 + i+1];
			rfilel += hex(reg, 4) + ' ';
			rfiler += ' ' + hex(regr,4);
		}
		mcr_file[rindex >> 5].innerText = rfilel + rfiler;
	}
	mcs_alu.innerText = malu1;
	mcs_alu2.innerText = malu2;
	mcs_alu3.innerText = malu3;
	mcs_p.innerText = `${mcp} ${mpc} ${mhr}`;
	mcs_s.innerText = mstk;
	mcr_res.innerText = hex(mcstate.result, 2);
	mcr_swap.innerText = hex(mcstate.swap, 2);
	mcr_level.innerText = hex(mcstate.level, 1);
	mcr_rfir.innerText = hex(mcstate.rir);
	mcr_rfdr.innerText = hex(mcstate.rdr);
	mcr_pta.innerText = hex(mcstate.pta, 1);

	if ((mcstate.sysctl & 16) != 0) {
		fp_runhalt[0].classList.add('a'); // run
		fp_runhalt[1].classList.remove('a');
	} else {
		fp_runhalt[0].classList.remove('a'); // halt
		fp_runhalt[1].classList.add('a');
	}
	if ((mcstate.sysctl & 64) != 0) {
		fp_flags[7].classList.add('a');
	} else {
		fp_flags[7].classList.remove('a');
	}
	for(let i = 0; i < 3; i++) {
		if ((mcstate.pta & (1<<i)) != 0) {
			fp_flags[4+i].classList.add('a');
		} else {
			fp_flags[4+i].classList.remove('a');
		}
		if ((mcstate.ccr & (8>>i)) != 0) {
			fp_flags[i].classList.add('a');
		} else {
			fp_flags[i].classList.remove('a');
		}
	}
	if ((mcstate.ccr & 1) != 0) {
		fp_flags[3].classList.add('a');
	} else {
		fp_flags[3].classList.remove('a');
	}
	const pindex = (mcstate.pta << 5);
	for (let k = 0; k < 4; k++) {
		let pgt = '';
		const psubindex = pindex | (k << 3);
		for (let i = 0; i < 8; i++) {
			const page = mcstate.page[psubindex | i];
			const pf = (page & 128) != 0;
			pgt += (pf ? '*':'.') + hex((page & 127) << 3, 3) + ' ';
		}
		mcpage[k].innerText = pgt;
	}
	// 'IntEN','AddrToSys','AddrCountEN','AddrU/D',
	// 'AddrCtlSel','?oSys29','?iSys64','?DMA_M8i3b'
	// mcstate.busctl
	
	const bc = mcstate.busctl;
	const sc = mcstate.sysctl;
	mcr_bus.innerText = `${(bc&1)>0?'I':'-'} ${(bc&2)>0?'--':'AE'} ${(bc&4)>0?'--':'AC'} ${(bc&8)>0?'U':'D'}` +
	` ${(bc&16)>0?'DA':'--'} ${(bc&32)>0?'e29':'---'}${(bc&64)>0?'MFI':'---'}${(bc&128)>0?'DMA':'---'}`;
	mcr_sys.innerText = `${(sc&1)>0?'DM4':'---'} ${(sc&2)>0?'DM3':'---'} ${(sc&4)>0?'TE':'--'} ${(sc&8)>0?'-':'M'}` +
	` ${(sc&16)>0?'R':'H'} ${(sc&32)>0?'--':'TR'} ${(sc&64)>0?'A':'-'} ${(sc&128)>0?'IA':'--'}`;
	const mpindex = pindex | ((mcstate.memaddr >> 11) & 31);
	const mpage = mcstate.page[mpindex];
	const mpaddress = ((mpage & 127) << 11) | (mcstate.memaddr & 0x7ff);
	mcr_addr.innerText = hex(mcstate.workaddr, 4) + ' ' + hex(mcstate.memaddr, 4) + ' ' + ((mpage & 128) != 0 ? '*' : '.') + hex(mpaddress, 5) + ' ' + hex(mcstate.physaddr, 5);
}

///////////////////////////////// Microcode stepping ////////////////////////////////////

// fast delay:
// 3ec 40 1B FFF8 92 800D orig
//     40 23 FFF8 fc 800D fast
// 3ed 40 23 7E11E1E00D orig
//     40 1b 7E11E1E00D fast
uc.f[0x3ec] = 0x23;
uc.m[0x3ec] = 0x01;
uc.f[0x3ed] = 0x1b;

interface DMAControl {
	read():number
	write(value:number):void
	end():void
}

function dma_request(stepfn:DMAFunc) {
	mcstate.dma_func = stepfn;
	mcstate.dma_13 = 1;
}

function mcstep(debug_output:boolean = false) {
	const pc = ((mcstate.s2.output << 8) | (mcstate.s1.output << 4) | (mcstate.s0.output)) & 0x7ff;
	if (pc == 0x101) {
		if (run_step > 0) {
			run_control(false);
			debug_output = true;
		}
		if (!run_busy || run_follow) {
			dis_after = true;
			dis_vpc = mcstate.physaddr & 0x3ffff;
		}
	}
	const v6 = /*A*/uc.k[pc]; // MSB
	const v5 = /*B*/uc.f[pc];
	const v4 = /*C*/uc.h[pc];
	const v3 = /*D*/uc.l[pc];
	const v2 = /*E*/uc.m[pc];
	const v1 = /*F*/uc.j[pc];
	const v0 = /*H*/uc.e[pc]; // LSB

	const x_k11 = (v0 >> 7) | ((v1 & 3) << 1);
	const x_h11 = (v1 >> 2) & 7;
	const x_f6h6 = (v6 >> 3) & 3;
	const x_c14_sel = bit(v6,7)!=0;
	const x_e7 = (v1 >> 5) & 3;
	const x_e6 = (v0 >> 4) & 7;
	const k9_en = bit(v1,7);
	const seq_branch = bit(v4,1);
	const sqd = v2 | ((v3 & 7)<<8);
	const selJ11 = (v2>>3) & 3;
	const enaJ11 = bit(v2,2);
	const selJ10 = ((v2>>6) & 3) | (bit(v3,0) << 2);
	const enaJ10 = bit(v2,5);
	const selJ12 = (v2 & 3);
	const selJ13 = (v2>>4) & 3;
	const selK13 = (v2>>6) & 3;
	const seq_pup = bit(v3,4); // TODO verify
	const k6b_a = bit(v4,0); // TODO verify
	const k6_imm = (bit(v6,6) & (k6b_a ^ 1)) ^ 1;
	const busctld = bit(v5,3);
	const busctla = (v5>>4) & 7;
	const busctlset = busctld << busctla;
	const busctlmask = ~(1 << busctla);
	
	const pindex = ((mcstate.memaddr >> 11) & 31) | (mcstate.pta << 5);
	const pgram = mcstate.page[pindex];
	const pgaddr = (pgram & 127) | (((pgram & 112) == 112) ? 128 : 0);
	const is_mmio = ((pgram & 253) == 253) ? 0 : 1;
	const is_reg = (((pgram & 127) == 0) && ((mcstate.memaddr & 1792) == 0)) ? 0 : 1;
	const is_regmmio = (is_reg & is_mmio) ^ 1;
	const notpgbit = (pgram >> 7) ^ 1;
	const is_mem = (is_reg & notpgbit) ^ 1;

	const intena = (mcstate.busctl & 1) != 0;
	const intreq = intena && bpl.is_interrupt(mcstate.level); // inverted on bus
	const sysint = mcstate.reqlevel;
	const dmaint = intena && (mcstate.level < 2) && (mcstate.dma_12 != 0);
	const count_up = (mcstate.busctl & 8)!=0;

	let k9_com = 1;
	if (k9_en == 0) {
		switch(v2 & 7) {
		case 0: /* TODO mcstate.f12b */ k9_com = 1; break;
		case 1: /* rir.0 nor 4 */
			k9_com = ((mcstate.rir | (mcstate.rir >> 4)) & 1)^1; break;
		case 2: /* rir.0 */ k9_com = mcstate.rir & 1; break;
		case 3: /* TODO: double check this (mmio/reg addressed) */
			k9_com = is_regmmio; break;
		case 4: /* REG/pbit */ k9_com = is_mem; break;
		case 5: /* DMA P2.13 */ k9_com = mcstate.dma_13; break;
		case 6: /* TODO B15A */ k9_com = mcstate.b15a ^ 1; break;
		case 7: /* TODO F13->H13A any INT */
			k9_com = mcstate.dma_13;
			if (intreq || dmaint) {
				k9_com = 1;
			}
			if (mcstate.rtc && ((mcstate.sysctl & 0x4) != 0)) {
				k9_com = 1;
			}
			break;
		}
		k9_com = k9_com ^ 1;
	}
	// branch and condition selectors
	let seq_or = 0;

	// seqencer control
	const seq0_s = ( (k9_com & bit(v3,5)) | ((k9_com & bit(v3,6))<<1) ) ^ 3;
	const seq12_s0 = (k9_com & bit(v3,7)) ^ 1; // TODO verify
	const seq1_s = seq12_s0|(((k9_com & k6_imm) ^ 1)<<1);
	const seq2_s = seq12_s0|(((k9_com & k6b_a) ^ 1)<<1);
	const seq_fc = seq_pup|((k9_com & bit(v3,3))<<1); // TODO verify FE (v3,3)

	let datapath = 0;
	const sense = sense_switch; // inverted on bus
	let sysdata = mcstate.memdata_in;
	const dswitch = 0; // inverted on bus - R H I M
	// Data Path Control
	switch(v0&15) {
	case 0: case 4: // R_SWP ⇒ DP
		datapath = mcstate.swap; break;
	case 1: case 5: // R_REG(d13) ⇒ DP
		datapath = mcstate.rdr; break;
	case 2: case 6: // R_ADM(rawH) ⇒ DP
		datapath = ((mcstate.memaddr >> 8) & 255) ^ 0xf0; break;
	case 3: case 7: // R_ADL ⇒ DP
		datapath = mcstate.memaddr & 255; break;
	case 8: // R_AddrPH ⇒ DP
		datapath = pgaddr; break;
	case 9: // CCR:sense ⇒ DP
		datapath = ((mcstate.ccr << 4) | sense) ^ 0xf0 /* TODO sense sw */; break;
	case 10: // R_SysDLatch ⇒ DP
		datapath = sysdata; break;
	case 11: // R_H14 ⇒ DP // TODO rest of H14? beware invertions
		datapath = (mcstate.level << 4) | 4 |
		(mcstate.resetting>0 ? 2 : 0) | (((pgram & 128) != 0) ? 0 : 1) |
		(dmaint ? 8 : 0);
		if(mcstate.resetting != 0) mcstate.resetting--;
		break;
	case 12: // R_DLI (int7..4:dipsw3..0[RHIM]) ⇒ DP
		// if ((mcstate.sysctl & 128) == 128) {
		// 	console.log('INT?', sysint);
		// }
		datapath = ((sysint & 15) << 4) | dswitch;
		break;
	case 13: // RCnst MCv2 ⇒ DP
		datapath = v2 ^ 0xff; // goes through a ls240
		break;
	// __ncE N/C
	// __ncF N/C
	}
	
	mcstate.aluh.in_data = datapath >> 4;
	mcstate.alul.in_data = datapath & 15;
	mcstate.alul.sel_a = mcstate.aluh.sel_a = (v6<<1)|(v5>>7);
	mcstate.alul.sel_b = mcstate.aluh.sel_b = v5>>3;
	mcstate.alul.src = mcstate.aluh.src = v4>>2;
	mcstate.alul.aop = mcstate.aluh.aop = v4>>5;
	mcstate.alul.dst = mcstate.aluh.dst = v5;

	switch(x_f6h6) {
	case 0: mcstate.alul.carry_in = 0; break;
	case 1: mcstate.alul.carry_in = 1; break;
	case 2: mcstate.alul.carry_in = (mcstate.alu_flag >> 3) & 1; break;
	case 3: mcstate.alul.carry_in = 0; break;
	}
	mcstate.alul.resolve();
	mcstate.aluh.carry_in = mcstate.alul.carry_out;
	mcstate.aluh.resolve();
	let h6a = 0, h6b = 0;
	switch(x_f6h6) {
	case 0: h6a = mcstate.aluh.sign; h6b = 0; break;
	case 1: h6a = h6b = ((mcstate.alu_flag >> 3) & 1); /* TODO both get flag.C? */ break;
	case 2: h6a = mcstate.alul.q0; h6b = mcstate.aluh.sign; break;
	case 3: h6a = mcstate.aluh.carry_out; h6b = 1; break;
	}
	if (mcstate.alul.is_right) {
		// >> 3.h.0 >> 3.l.0 >>
		mcstate.alul.q3 = mcstate.aluh.q0;
		mcstate.alul.ram3 = mcstate.aluh.ram0;
		mcstate.aluh.q3 = mcstate.alul.ram0;
		mcstate.aluh.ram3 = h6a; // h6.Za
	} else {
		// << 3.h.0 << 3.l.0 <<
		mcstate.aluh.q0 = mcstate.alul.q3;
		mcstate.aluh.ram0 = mcstate.alul.ram3;
		mcstate.alul.q0 = h6b; // h6.Zb
		mcstate.alul.ram0 = mcstate.aluh.q3;
	}
	let data_f = (mcstate.aluh.out_f << 4) | mcstate.alul.out_f;
	if (x_h11 == 6) {// Select MAPROM to F
		data_f = uc.map[datapath];
	}

	// uses ALU flags, so must be after comb logic resolve
	if (seq_branch == 0) {
		switch(selJ13) {
		case 0: // |1 IF ALUF.S, |2 IF ALUF.Z
			seq_or |= ((mcstate.alu_flag & 2)!=0 ?1:0);
			seq_or |= ((mcstate.alu_flag & 1)!=0 ?2:0);
			break;
		case 1: // |1 IF ALUF.H, |2 IF ALUF.V
			seq_or |= ((mcstate.alu_flag & 16)!=0 ?1:0);
			seq_or |= ((mcstate.alu_flag & 4)!=0 ?2:0);
			break;
		case 2: // |1 IF ~pbit, |2 IF ~MMIO
			seq_or |= 1 | (is_mmio << 1); // TODO pbit
			break;
		case 3: break; // nop
		}

		switch(selK13) { // mind the strange order of OR2/3 (|4 |8)
		case 0: // |4 IF INT_EN, |8 IF CCR.Carry (Link)
			if (intena) seq_or |= 4; // TODO: trace
			if ((mcstate.ccr & CCR.CARRY) != 0) seq_or |= 8;
			break;
		case 1: // |4 IF DMA_INT, |8 IF INT_REQ
			if (!dmaint) seq_or |= 4; // TODO verify these work
			if (!intreq) seq_or |= 8; // TODO?
			break;
		case 2: // |4 IF MEM_INT, |8 IF DMA.P2.13
			//seq_or |= 4; // TODO typically low
			if (mcstate.dma_13 == 0) seq_or |= 8; // TODO - typically high if no DMA connection
			break;
		case 3: break; // nop
		}

		seq_or |= mcstate.override_or;
	}

	let rindex;
	if (x_c14_sel) {
		rindex = (mcstate.rir & 15) | (mcstate.level << 4);
	} else {
		rindex = (mcstate.rir & 255);
	}
	// rindex bit 0, this is technically a NOR
	// but can be handled as needed because this is the only reference
	rindex = (rindex | bit(v6,5)); // I elected to not invert it, since the debug dump would have anyways

	if (debug_output) {
		const k9_fn = 'K9=' + ((k9_en == 0) ? 'nop' : [
			'(0)BusAct', // if RDIN or WTIN have been asserted by the CPU
			'(1)RIR.~0|4',
			'(2)RIR.0',
			'(3)Ad=IO/REG',
			'(4)Ad=REG/pbit', // need to recheck the logic on this one to give it a better name
			'(5)~DMA_P2.13', // DMA port, no clue otherwise
			'(6)B15A.~Q', // this one is weird, depends on BusCtl bit 6 being set
			'(7)F13 most' // this one needs a better name (checks multiple interrupt lines)
			][v2 & 7]);
		const d_branch = ['','','',''];
		if (seq_branch == 0) {
			switch(selJ13) {
			case 0:
				if ((sqd | 1) != sqd) d_branch[0] = '|1 IF ALUF.S';
				if ((sqd | 2) != sqd) d_branch[1] = '|2 IF ALUF.Z';
				break;
			case 1:
				if ((sqd | 1) != sqd) d_branch[0] = '|1 IF ALUF.H';
				if ((sqd | 2) != sqd) d_branch[1] = '|2 IF ALUF.V';
				break;
			case 2:
				if ((sqd | 1) != sqd) d_branch[0] = '|1 IF (!)~pbit';
				if ((sqd | 2) != sqd) d_branch[1] = '|2 IF ~MMIO';
				break;
			case 3: break; // nop
			}
			switch(selK13) {
			case 0:
				if ((sqd | 4) != sqd) d_branch[2] = '|4 IF INT_EN';
				if ((sqd | 8) != sqd) d_branch[3] = '|8 IF CCR.L';
				break;
			case 1:
				if ((sqd | 4) != sqd) d_branch[2] = '|4 IF (!)DMA_INT';
				if ((sqd | 8) != sqd) d_branch[3] = '|8 IF (!)INT_REQ';
				break;
			case 2:
				if ((sqd | 4) != sqd) d_branch[2] = '|4 IF (!)MEM_INT';
				if ((sqd | 8) != sqd) d_branch[3] = '|8 IF (!)DMA.P2.13';
				break;
			case 3: break; // nop
			}
		}
		const d_f6h6 = ['F6=0   ','F6=1   ','F6=FL.C','F6=?3  '][x_f6h6] +
		' H6:' + (mcstate.alul.is_right ? ['alu.s','AFL.C','q0','alu.c'][x_f6h6] : ['0','AFL.C','alu.s','1'][x_f6h6]).padEnd(5);
		const lh = mcstate.alul.funcstr().padEnd(30); // speculative
		const lseq = `S2:${FN_SEQ_SN[seq2_s]} S1:${FN_SEQ_SN[seq1_s]} S0:${FN_SEQ_SN[seq0_s]} ${FN_SEQ_FE[seq_fc]}`;
		const l34 = `[${hex(sqd,3)}][${d_branch.join(',')}]`;
		const d_ccr =
			'cV=' + ['. ','Z ','R.V','LZ'][selJ12] +
			' cM=' + ['. ','S ','R.M','S '][selJ12] +
			' cF=' + (enaJ11 ? '0' : ['Res.5','1','.','0','Res.5','1','.','1'][selJ11 | (mcstate.alu_flag & 0x4)]).padEnd(4) +
			' cL=' + (enaJ10 ? '0' : ['.','~','C','(3)0','R.L','ALU.7','ALU.0/Q7','ALU.Q0'][selJ10]).padEnd(8);
		mcs_op.innerText = `${hex(pc)}:${hex(v6)}${hex(v5)}${hex(v4)}${hex(v3)}${hex(v2)}${hex(v1)}${hex(v0)}: ${lseq} ${k9_fn} ${l34}`;
		mcs_op_alu.innerText = `${lh} (${hex(data_f,2)}) ${d_f6h6} ${d_ccr}`;
	}

	////////////////////////////// rising clock edge /////////////////////////////

	let prevwork = mcstate.workaddr;
	switch(x_k11) {
	case 0: break; // nop
	case 1: break; // L13A_SET
	case 2: // ?K11_2
		if ((busctlset == 1) && ((mcstate.sysctl & 1) == 0)) {
			console.log('DMA1:ON');
		}
		if ((busctlset == 2) && ((mcstate.sysctl & 2) == 0)) {
			console.log('DMA2:ON');
		}
		if ((busctlset == 128) && ((mcstate.sysctl & 128) == 0)) {
			//console.log('IACK:', mcstate.level);
			mcstate.reqlevel = bpl.ack_interrupt(mcstate.level);
			//console.log('IACK:', mcstate.level,'->',mcstate.reqlevel);
		}
		if ((busctlmask == ~128) && ((mcstate.sysctl & 128) == 128)) {
			//bpl.ack_interrupt(false);
			mcstate.reqlevel = 0;
		}
		mcstate.sysctl = (mcstate.sysctl & busctlmask) | busctlset;
		break;
	case 3: // BusCtl
		mcstate.busctl = (mcstate.busctl & busctlmask) | busctlset;
		break;
	case 4: // REG_WR
		mcstate.file[rindex] = mcstate.result;
		break;
	case 5: // PTR_WR
		mcstate.page[pindex] = mcstate.result;
		break;
	case 6: // WADL_WR
		if (x_e6 == 5) {
			mcstate.workaddr = (mcstate.workaddr & 0xff00) | (mcstate.memaddr & 0xff);
		} else {
			mcstate.workaddr = (mcstate.workaddr & 0xff00) | mcstate.result;
		}
		break;
	case 7: // BusD_WR
		mcstate.memdata_out = data_f;
		mcstate.sys_write_latch = true;
		break;
	}

	// timer
	mcstate.cycles++;
	if (mcstate.cycles >= 1000) {
		mcstate.cycles = 0;
		if ((mcstate.sysctl & 0x20) != 0) {
			mcstate.rtc = true;
		}
	}
	if ((mcstate.sysctl & 0x20) == 0) {
		mcstate.rtc = false;
	}

	// conditions register
	if (x_e6 == 7) {
		// alu_flag:
		//  LHCVSZ
		//  543210
		// L<<3 F<<2 M<<1 V<<0

		let fl_v = 0;
		let fl_m = 0;
		switch(selJ12) {
		case 0:
			fl_v = (mcstate.ccr >> CCR.BIT_V) & 1;
			fl_m = (mcstate.ccr >> CCR.BIT_M) & 1;
			break;
		case 1:
			fl_v = (mcstate.alu_flag) & 1;
			fl_m = (mcstate.alu_flag >> 1) & 1;
			break;
		case 2:
			fl_v = (mcstate.result >> 7) & 1;
			fl_m = (mcstate.result >> 6) & 1;
			break;
		case 3:
			fl_v = (mcstate.alu_flag & (mcstate.alu_flag >> 5)) & 1;
			fl_m = (mcstate.alu_flag >> 1) & 1;
			break;
		}
		let fl_f = 0;
		let fl_l = 0;
		if (enaJ11 == 0) {
			switch(selJ11 | (mcstate.alu_flag & 0x4)) {
			case 0: fl_f = (mcstate.result >> 5) & 1; break;
			case 1: fl_f = 1; break;
			case 2: fl_f = (mcstate.ccr >> CCR.BIT_F) & 1; break;
			case 3: fl_f = 0; break;
			case 4: fl_f = (mcstate.result >> 5) & 1; break;
			case 5: fl_f = 1; break;
			case 6: fl_f = (mcstate.ccr >> CCR.BIT_F) & 1; break;
			case 7: fl_f = 1; break;
			}
		}
		if (enaJ10 == 0) {
			switch(selJ10) {
			case 0: fl_l = ((mcstate.ccr >> CCR.BIT_L) & 1); break;
			case 1: fl_l = ((mcstate.ccr >> CCR.BIT_L) & 1) ^ 1; break;
			case 2: fl_l = (mcstate.alu_flag >> 3) & 1; break;
			case 3: fl_l = 1; break;
			case 4: fl_l = (mcstate.result >> 4) & 1; break;
			case 5: fl_l = mcstate.aluh.ram3; break;
			case 6: fl_l = mcstate.alul.ram0; break;
			case 7: fl_l = mcstate.alul.q0; break;
			}
		}
		mcstate.ccr = (fl_l << CCR.BIT_L) | (fl_f << CCR.BIT_F) | (fl_m << CCR.BIT_M) | (fl_v << CCR.BIT_V);
	}

	mcstate.rdr = mcstate.file[rindex];

	switch(x_e7) {
	case 0: break; // nop
	case 1: break; // TODO: BusReady
	case 2: // ALUFlag_LD
		mcstate.alu_flag = (mcstate.alul.zero & mcstate.aluh.zero) |
		(mcstate.aluh.sign << 1) | (mcstate.aluh.over << 2) |
		(mcstate.aluh.carry_out << 3) | (mcstate.alul.carry_out << 4) | ((mcstate.alu_flag & 1) << 5);
		break;
	case 3: // DataRD
		if (mcstate.sys_write_latch) {
			mcstate.memdata_in = mcstate.memdata_out;
		} else if (in_dbgdat.value != '') {
			mcstate.memdata_in = parseInt(in_dbgdat.value, 16) & 255;
		} else {
			mcstate.memdata_in = bpl.readbyte(mcstate.physaddr & 0x3ffff);
		}
		mcstate.sys_write_latch = false;
		break;
	}

	let c = mcstate.s0.step(true, seq0_s, seq_fc, v2 & 15, seq_or, false);
	c = mcstate.s1.step(c, seq1_s, seq_fc, v2 >> 4, 0, false);
	mcstate.s2.step(c, seq2_s, seq_fc, v3 & 7, 0, false);

	if (((mcstate.busctl & 20) == 16) && mcstate.dma_func != null) {
		mcstate.dma_func((mcstate.workaddr == 0xffff), {
			read():number {
				mcstate.physaddr = (pgaddr << 11) | (mcstate.memaddr & 0x7ff);
				let v = bpl.readbyte(mcstate.physaddr & 0x3ffff);
				mcstate.workaddr = (mcstate.workaddr + (count_up?1:-1)) & 0xffff;
				mcstate.memaddr = (mcstate.memaddr + (count_up?1:-1)) & 0xffff;
				return v;
			},
			write(value:number) {
				mcstate.physaddr = (pgaddr << 11) | (mcstate.memaddr & 0x7ff);
				bpl.writebyte(mcstate.physaddr & 0x3ffff, value);
				mcstate.workaddr = (mcstate.workaddr + (count_up?1:-1)) & 0xffff;
				mcstate.memaddr = (mcstate.memaddr + (count_up?1:-1)) & 0xffff;
			},
			end():void {
				mcstate.dma_13 = 0;
				mcstate.dma_func = null;
			}
		});
	}
	switch(x_h11) {
	case 0: break; // nop
	case 1: // RD_START /* TODO */
		mcstate.physpre = pgram >> 7;
		mcstate.physaddr = (pgaddr << 11) | (mcstate.memaddr & 0x7ff);
		break;
	case 2: // WT_START /* TODO */
		mcstate.physpre = pgram >> 7;
		mcstate.physaddr = (pgaddr << 11) | (mcstate.memaddr & 0x7ff);
		bpl.writebyte(mcstate.physaddr & 0x3ffff, mcstate.memdata_out);
		break;
	case 3: // WorkAddr_LDH
		if (x_e6 == 5) {
			mcstate.workaddr = (mcstate.workaddr & 0x00ff) | (mcstate.memaddr & 0xff00);
		} else {
			mcstate.workaddr = (mcstate.workaddr & 0x00ff) | (mcstate.result << 8);
		}
		break;
	case 4: // WorkAddr_Count
		mcstate.workaddr = (mcstate.workaddr + (count_up?1:-1)) & 0xffff;
		break;
	case 5: // MemAddr_Count
		mcstate.memaddr = (mcstate.memaddr + (count_up?1:-1)) & 0xffff;
		break;
	case 6: break; // F=MapROM - handled farther above
	case 7: // NibSwap
		mcstate.swap = ((datapath << 4) | (datapath >> 4)) & 255;
		break;
	}

	switch(x_e6) {
	// no case 0
	case 1: mcstate.result = data_f; break; // F⇒Result
	case 2: mcstate.rir = data_f; break; // F⇒RIdx
	case 3: mcstate.level = data_f >> 4; break; // F⇒Level
	case 4: mcstate.pta = data_f & 7; break; // F⇒PTA
	case 5: mcstate.memaddr = prevwork; break; // ASwap
	case 6: // SEQ_RE
		mcstate.s0.h = data_f & 15;
		mcstate.s1.h = (data_f >> 4) & 15;
		break;
	case 7: break; //!E6:O7
	}

	if(debug_output) {
		const d_k11 = [// FN_K11[x_k11]
		/* 0 */ 'nop',
		/* 1 */ '(!)L13A_SET',
		/* 2 */ 'SysCtl:' + [ // M13 maybe, I have no input signals for this, but it works
		/* . */ 'P2.3','P2.4','RTC','MapDis',
		/* . */ 'FP.Run','RTC.R','FP.ABT','INT_ACK'][busctla] + '=' + busctld,
		/* 3 */ 'BusCtl:' + [
		/* . */ 'IntEN','AddrToSys','AddrCountEN','AddrU/D',
		/* . */ 'AddrCtlSel','?oSys29','?iSys64','?DMA_M8i3b'][busctla] + '=' + busctld,
		/* 4 */ x_c14_sel ? 'REG_WR(LV)' : 'REG_WR(RI)',
		/* 5 */ 'PTR_WR',
		/* 6 */ 'WA_LD',
		/* 7 */ '(!)BusD_WR'][x_k11]
		const mce7 = 'E7='+['nop','(!)BusReady','ALUFlag_LD','(!)DataRD'][x_e7];
		const mch11 = 'H11='+[
		'nop','(!)RD_START','(!)WT_START','WorkAddr_LDH',
		'(~!)WorkAddr_Count','(~!)MemAddr_Count','F=MapROM','NibSwap'][x_h11]
		const mcd_d45 = 'DP=' + [
		'SWAPR','RDR','MA_H','MA_L','SWAPR','RDR','MA_H','MA_L',
		'PA','CCR_DSense','SysDAT','(!)R_H14','(!)R_INTDIP','RCnst','',''][v0&15];
		const mch = `D4/5:${mcd_d45.padEnd(10)}(${hex(datapath)}) E6=${FN_E6[x_e6].padEnd(12)}`;
		mcs_op_bus.innerText = `K11:${d_k11.padEnd(12)} ${mch} ${mce7.padEnd(13)} ${mch11}`;
	}
	mcstate.alul.step();
	mcstate.aluh.step();
}
mcshowstate();

class DiagIO {
	// TOS:1a, Aux:1d, Hawk:17-19, MUXINT:16, DMA:11/13
	dip = 0x0d;
	hexout = 0;
	points = 0;
	blank = false;
	read(f:number):number {
		let v;
		switch(f) {
		case 6: this.blank = false; break;
		case 7: this.blank = true; break;
		case 8: this.points |= 1; break;
		case 9: this.points &= 0xe; break;
		case 10: this.points |= 2; break;
		case 11: this.points &= 0xd; break;
		case 12: this.points |= 4; break;
		case 13: this.points &= 0xb; break;
		case 14: this.points |= 8; break;
		case 15: this.points &= 0x7; break;
		case 16: v = this.dip & 255;
			return v;
		default: return 0;
		}
		cx_diag.clearRect(0, 0, 40, 30);
		if (!this.blank) cx_diag.fillText('00', 10, 20);
		if ((this.points & 1) != 0) cx_diag.fillText('.', 5, 8);
		if ((this.points & 2) != 0) cx_diag.fillText('.', 5, 25);
		if ((this.points & 4) != 0) cx_diag.fillText('.', 25, 8);
		if ((this.points & 8) != 0) cx_diag.fillText('.', 25, 25);
		return 0;
	}
	write(f:number, v:number):void {
		if (f == 16) this.hexout = v;
		this.read(f);
	}
}
const cx_diag0 = new DiagIO();

interface MemAccessW {
	writebyte(address:number, value:number):void;
	is_write:boolean;
}
interface MemAccessR {
	readbyte(address:number):number;
	is_io?:boolean;
	is_write?:boolean;
}
interface IOAccess {
	is_interrupt():boolean;
	getlevel():number;
	acknowledge():boolean;
	reset():void;
}
interface AddressTransform {
	remap?:number[];
	invert?:boolean;
}

class DSK2Unit {
	sel_address = 0;
}
class DSK2 implements MemAccessR, MemAccessW, IOAccess {
	is_io = true;
	is_write:true = true;
	sel_unit = 0;
	units = [new DSK2Unit(), new DSK2Unit()];
	busy = false;
	busy_time = 0;
	wpmask = 0;
	seeking = false;
	seek_done = false;
	sect_remain = 0;
	command = -1;
	interrupt_en = false;
	interrupt_pend = false;
	is_interrupt(): boolean {
		this.tickbusy();
		return false;
	}
	getlevel():number {
		return 2; // seems like a good number :)
	}
	acknowledge():boolean {
		console.log('DSK2:IACK');
		let v = this.interrupt_pend;
		this.interrupt_pend = false;
		return v;
	}
	reset(): void {
		this.command = -1;
		this.seeking = false;
		this.seek_done = false;
		this.busy = false;
		this.busy_time = 0;
		this.wpmask = 0;
		this.sel_unit = 0;
		this.interrupt_en = false;
		mcstate.dma_12 = 0;
	}
	tickbusy() {
		if (this.busy_time > 0) {
			this.busy_time--;
			if (this.busy_time == 0) {
				this.busy = false;
				switch(this.command) {
				case 0:
				case 1:
					
					break;
				case 2:
					this.seeking = false;
					this.seek_done = true;
					if (this.interrupt_en) mcstate.dma_12 = 1;
					break;
				case 3:
					this.seeking = false;
					this.seek_done = true;
					if (this.interrupt_en) mcstate.dma_12 = 1;
					console.log('DSK2:done:rtz');
					break;
				default:
					if (this.command != -1) {
						console.log('unknown command');
					}
				}
				this.command = -1;
			}
		}
	}
	readbyte(address:number):number {
		let v = 0;
		let u;
		switch(address) {
		case 0:
			v = this.sel_unit;
			break;
		case 1: // cylh
			u = this.units[this.sel_unit];
			if (u) {
				v = u.sel_address >> 8;
			}
			break;
		case 2: // cyll:h:sec
			u = this.units[this.sel_unit];
			if (u) {
				v = u.sel_address & 0xff;
			}
			break;
		case 3: // wpmask?
			v = this.wpmask;
			break;
		case 4: // stat hi / 0 tmo adrerr fmterr | 0 seekerr fault busy
			if (this.sel_unit == 1 || this.sel_unit == 0) {
				this.tickbusy();
				v = ((this.busy || this.seeking) ? 1 : 0);
			}
			break;
		case 5: // stat lo / wtpr wten oncyl ready | seekcom3..0
			if (this.sel_unit == 1 || this.sel_unit == 0) {
				this.tickbusy();
				v = 0x80 /* wp */ | (this.seeking ? 0 : 0x20) /* oncyl */ |
				(disk_images.main_view != null ? 0x10 : 0) /* ready */ |
				(this.seek_done ? 0x01 : 0);
			}
			break;
		case 8: // busy?
			if (this.sel_unit == 1 || this.sel_unit == 0) {
				this.tickbusy();
				v = ((this.busy || this.seeking) ? 1 : 0);
			}
			break;
		default:
			console.log('DSK2:R:', hex(address, 1), hex(v));
		}
		return v;
	}
	do_dma_read() {
		const u = this.units[this.sel_unit];
		if (u == null) return;
		dma_request((atend, ctrl)=>{
			if (atend || disk_images.main_view == null) {
				ctrl.end();
				this.busy_time = 10;
			} else {
				if (this.sect_remain <= 0) {
					this.sect_remain = 400;
					u.sel_address++;
				}
				const fileaddr = u.sel_address * 512;
				let b = disk_images.main_view.getUint8(fileaddr + 400 - this.sect_remain);
				ctrl.write(b);
				this.sect_remain--;
			}
		});
	}
	writebyte(address:number, value:number):void {
		const u = this.units[this.sel_unit];
		switch(address) {
		case 0:
			this.sel_unit = value & 0x7;
			break;
		case 1: // cylh
			if (u) {
				u.sel_address = (u.sel_address & 0xff) | (value << 8);
			}
			break;
		case 2: // cyll:h:sec
			if (u) {
				u.sel_address = (u.sel_address & 0xff00) | (value & 0xff);
			}
			break;
		case 3: // wpmask
			this.wpmask = value & 0xff;
			break;
		case 8: // cmd
			if (u == null) break;
			// 0=read
			// 1=write
			// 2=seek
			// 3=rtzcal
			// 4=format?
			this.seek_done = false;
			this.busy = true;
			this.command = value;
			switch (value) {
			case 0:
				console.log('DSK2:read:', hex(u.sel_address, 4));
				this.busy_time = 0;
				this.sect_remain = 400;
				if (this.interrupt_en) mcstate.dma_12 = 1;
				this.do_dma_read();
				break;
			case 1:
				console.log('DSK2:write:', hex(u.sel_address, 4));
				break;
			case 2:
				//console.log('DSK2:seek:', hex(this.sel_address, 4));
				this.busy_time = 40;
				this.seeking = true;
				break;
			case 3:
				console.log('DSK2:rtz');
				this.busy_time = 200;
				this.seeking = true;
				break;
			default:
				console.log('DSK2:cmd:', hex(value));
				this.busy_time = 10;
				break;
			}
			break;
		case 12:
			if (this.interrupt_en) mcstate.dma_12 = 1;
			console.log('DSK2:W:IFORCE');
			break;
		case 13:
			this.interrupt_en = false;
			mcstate.dma_12 = 0;
			console.log('DSK2:W:INTOFF');
			break;
		case 14:
			this.interrupt_en = true;
			console.log('DSK2:W:INTON');
			break;
		case 15:
			mcstate.dma_12 = 0;
			console.log('DSK2:W:INTCLEAR');
			if (this.interrupt_en && (this.command == 0)) {
				//this.do_dma_read();
			}
			break;
		default:
			console.log('DSK2:W:', hex(address, 1), hex(value));
		}
		return;
	}
}
const dsk2_0 = new DSK2();

class MUXPort {
	write_busy = false;
	write_full = false;
	read_busy = false;
	read_full = false;
	buf_write = 0;
	card:MMIOMux;
	constructor(card:MMIOMux) {
		this.card = card;
	}
	read_status():number {
		return (this.write_busy ? 0 : 2) | (this.read_busy ? 1 : 0) | 0x20;
	}
	read_data():number {
		let vcc = cx_crt0.input_buf.shift();
		if (cx_crt0.input_buf.length == 0) this.read_busy = false;
		if (vcc != undefined) {
			return vcc;
		}
		return 0;
	}
	write_control(value:number):void {
	}
	write_data(value:number):void {
		this.write_busy = true;
		this.buf_write = value;
		//setTimeout(()=>{
			this.write_busy = false;
			cx_crt0.write(this.buf_write & 0x7f);
		//}, 0);
	}
	receive():void {
		this.read_busy = true;
		this.card.interrupt_pend = true;
		this.card.mux_cause = true;
	}
}

class MMIOMulti implements MemAccessR, MemAccessW {
	is_io = true;
	is_write:true = true;
	readbyte(address: number):number {
		if (address >= 6 && address <= 0x10) {
			return cx_diag0.read(address);
		} else if (address >= 0x40 && address < 0x50) {
			return dsk2_0.readbyte(address - 0x40);
		}
		return 0;
	}
	writebyte(address: number, value: number):void {
		if (address >= 6 && address <= 0x10) {
			return cx_diag0.write(address, value);
		} else if (address >= 0x40 && address < 0x50) {
			dsk2_0.writebyte(address - 0x40, value);
		}
	}
}
class MMIOMux implements MemAccessR, MemAccessW, IOAccess {
	is_interrupt():boolean {
		if (!this.interrupt_en) return false;
		return this.interrupt_pend;
	}
	getlevel():number {
		return this.interrupt_level;
	}
	acknowledge():boolean {
		//console.log('MUX:IACK');
		if (this.interrupt_pend) {
			this.interrupt_pend = false;
			return true;
		}
		return false;
	}
	reset():void {
		this.interrupt_en = false;
		this.interrupt_level = 0;
		this.interrupt_pend = false;
		this.mux_cause = false;
	}
	muxports:MUXPort[] = [new MUXPort(this)];
	is_io = true;
	is_write:true = true;
	interrupt_level = 0;
	interrupt_en = false;
	interrupt_pend = false;
	mux_cause = false;
	tx_int = 0;
	readbyte(address:number):number {
		let v = 0;
		if (address < 8) {
			let selmux = this.muxports[address >> 1];
			if (selmux) {
				if ((address & 1) != 0) v = selmux.read_data();
				else v = selmux.read_status();
			}
		} else if (address == 15) {
			if (this.mux_cause) {
				this.mux_cause = false;
				if (cx_crt0.input_buf.length > 0) {
					v = 0; // (card_id << 4)
				} else if (this.tx_int > 0) {
					v = 0; // (card_id << 4)
					for(let i = 0; i < 4; i++) {
						let q = 1 << i;
						if ((this.tx_int & q) != 0) {
							v |= (i << 1) | 1;
							this.tx_int ^= q;
							break;
						}
					}
				}
			}
			//console.log('MUX:R:' + hex(address,1), hex(v));
		} else {
			console.log('MUX:R:' + hex(address,1), hex(v));
		}
		return v;
	}
	writebyte(address:number, value:number):void {
		if (address < 8) {
			let port = address >> 1;
			let selmux = this.muxports[port];
			if (selmux) {
				if ((address & 1) != 0) {
					selmux.write_data(value);
					this.tx_int |= 1 << port;
					this.interrupt_pend = true;
					this.mux_cause = true;
				} else {
					selmux.write_control(value);
				}
			}
		} else if (address == 10) {
			this.interrupt_level = value & 0xf;
		} else if (address == 12) {
			this.tx_int |= (value & 0xf);
			this.interrupt_pend = true;
			this.mux_cause = true;
			console.log('MUX:IFORCE');
		} else if (address == 13) {
			this.interrupt_en = false;
		} else if (address == 14) {
			this.interrupt_en = true;
		} else if (address == 15) {
			this.reset();
		} else {
			console.log('MUX:W:' + hex(address), hex(value));
		}
		return;
	}
}
abstract class MemBase implements MemAccessR {
	contents:ArrayBuffer;
	view:DataView;
	constructor(init?:{hex?:string,bin?:Uint8Array,addr?:AddressTransform}) {
		this.contents = this.allocate();
		this.view = new DataView(this.contents);
		if (init) {
			if (init.bin !== undefined) {
				this.loadbin(init.bin, init.addr);
			}
			if (init.hex !== undefined) {
				this.loadhex(init.hex);
			}
		}
	}
	allocate():ArrayBuffer {
		throw new Error('abstract');
	}
	readbyte(address:number):number {
		return this.view.getUint8(address);
	}
	loadbin(v:Uint8Array, addrfn?:AddressTransform) {
		const l = v.length;
		if (addrfn == null) {
			for (let a = 0; a < l; a++) {
				this.view.setUint8(a, v[a]);
			}
		} else {
			let xm = addrfn.invert ? (l - 1) : 0;
			const remap = addrfn.remap;
			if (remap) {
				const aremapfn = function(addr_in:number):number {
					let atx = 0;
					for (let i = 0; i < remap.length; i++) {
						atx |= ((addr_in >>> remap[i]) & 1) << i;
					}
					return atx;
				};
				for (let a = 0; a < l; a++) {
					let txa = aremapfn(a ^ xm);
					this.view.setUint8(a, v[txa]);
				}
			} else {
				for (let a = 0; a < l; a++) {
					let txa = a ^ xm;
					this.view.setUint8(a, v[txa]);
				}
			}
			
		}
	}
	// load a space/lf delimited list of hex values
	loadhex(h:string, ofs:number = 0):void {
		let msh = h.split(/[ \n]/);
		let vpc = ofs;
		msh.forEach(value=>{
			if (value !== '') {
				let v = parseInt(value, 16);
				this.view.setUint8(vpc, v & 0xff);
				vpc++;
			}
		});
	}
}
abstract class RamBase extends MemBase implements MemAccessR, MemAccessW {
	is_io = false;
	is_write = true;
	writebyte(address: number, value: number): void {
		this.view.setUint8(address, value & 255);
	}
}
class ROM512 extends MemBase {
	allocate(): ArrayBuffer {
		return new ArrayBuffer(512);
	}
}
class ROM2k extends MemBase {
	allocate(): ArrayBuffer {
		return new ArrayBuffer(2048);
	}
}
class RAM2k extends RamBase {
	allocate(): ArrayBuffer {
		return new ArrayBuffer(2048);
	}
}
class SysMem extends RamBase {
	allocate(): ArrayBuffer {
		return new ArrayBuffer(4096);
	}
}

const enum OPM {
	IMPL,
	IMM, DIR, IND, PCO, IPO, MOD,
	RR, RC, RRX,
	IMPL_R,
	IMPL_R_DIR,
}
const enum TXS {
	B, W, F
}
const enum OPL_EXT {
	MPUSH, MPOP,
	DMA,
}
interface OPLEntry {
	n:string,
	nm?:string,
	l?:number,
	i?:number,
	ms?:OPM,
	md:OPM,
	w?:TXS,
	sr?:REG,
	dr?:REG,
	x?:OPL_EXT,
}

const enum REG {
	A, AL, B, BL, X, XL, Y, YL,
	Z, ZL, S, SL, C, CL, PC, PCL
}
const regname = [
	'AH','AL','BH','BL','XH','XL','YH','YL',
	'ZH','ZL','SH','SL','CH','CL','PCH','PCL',
	'A','A!','B','B!','X','X!','Y','Y!',
	'Z','Z!','S','S!','C','C!','PC','PC!',
]
const mmwlist = new Map<number, string>([]);

const mmiolist = new Map([
	[0x00fe,'cpu_reg_ph15'],
	[0xf106,'diag_unblank'],
	[0xf107,'diag_blankhex'],
	[0xf108,'dp1_set'],
	[0xf109,'dp1_clear'],
	[0xf10a,'dp2_set'],
	[0xf10b,'dp2_clear'],
	[0xf10c,'dp3_set'],
	[0xf10d,'dp3_clear'],
	[0xf10e,'dp4_set'],
	[0xf10f,'dp4_clear'],
	[0xf110,'diag_dip_hex'],
	[0xf201,'mux0_rx_tx'],
	[0xf200,'mux0_stat_ctl'],
	// TODO these correct?
	[0xf203,'mux1_rx_tx'],
	[0xf202,'mux1_stat_ctl'],
	[0xf205,'mux2_rx_tx'],
	[0xf204,'mux2_stat_ctl'],
	[0xf207,'mux3_rx_tx'],
	[0xf206,'mux3_stat_ctl'],
	[0xf208,'mux_mmio_08'],
	[0xf209,'mux_mmio_09'],
	[0xf20a,'mux_mmio_0a'],
	[0xf20b,'mux_mmio_0b'],
	[0xf20c,'mux_mmio_0c'],
	[0xf20d,'mux_mmio_0d'],
	[0xf20e,'mux_mmio_0e'],
	[0xf20f,'mux_mmio_0f'],
]);

if(true) {
	for(let i = 0; i < 256; i++) {
		if ((i & 1) == 0) {
			mmwlist.set(i, `cpu_reg_${regname[16+(i & 15)].toLowerCase()}${i >> 4}`);
		}
		mmiolist.set(i, `cpu_reg_${regname[(i & 15)].toLowerCase()}${i >> 4}`);
	}
}

let NAME_CONV = 1;
const NB = String.fromCodePoint(0xa0);

const oplist:OPLEntry[] = [
	// 0x0H
	{n:'HALT',md:OPM.IMPL},{n:'NOP',md:OPM.IMPL},
	{n:'SF',md:OPM.IMPL},{n:'RF',md:OPM.IMPL},
	{n:'EI',md:OPM.IMPL},{n:'DI',md:OPM.IMPL},
	{n:'SL',md:OPM.IMPL},{n:'RL',md:OPM.IMPL},
	{n:'CL',nm:'COML',md:OPM.IMPL},{n:'RSR',nm:'RET',md:OPM.IMPL},
	{n:'RI',nm:'RTI',md:OPM.IMPL},{n:'RIM',nm:'RTIM',md:OPM.IMPL},
	{n:'ELO',md:OPM.IMPL},
	{n:'PCX',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.PC,dr:REG.X},
	{n:'DLY',nm:'DELAY',md:OPM.IMPL},{n:'SYSRET',md:OPM.IMPL},
	// 0x1H
	{n:'BL',md:OPM.PCO,w:TXS.F},{n:'BNL',md:OPM.PCO,w:TXS.F},
	{n:'BF',md:OPM.PCO,w:TXS.F},{n:'BNF',md:OPM.PCO,w:TXS.F},
	{n:'BZ',md:OPM.PCO,w:TXS.F},{n:'BNZ',md:OPM.PCO,w:TXS.F},
	{n:'BM',md:OPM.PCO,w:TXS.F},{n:'BP',md:OPM.PCO,w:TXS.F},
	{n:'BGE',md:OPM.PCO,w:TXS.F},{n:'BLE',md:OPM.PCO,w:TXS.F},
	{n:'BS1',md:OPM.PCO,w:TXS.F},{n:'BS2',md:OPM.PCO,w:TXS.F},
	{n:'BS3',md:OPM.PCO,w:TXS.F},{n:'BS4',md:OPM.PCO,w:TXS.F},
	{n:'?BTM?',md:OPM.IMPL},{n:'?BEP?',md:OPM.IMPL},
	// 0x2H
	{n:'INRB',nm:'INC',md:OPM.RC,w:TXS.B,i:1},{n:'DCRB',nm:'DEC',md:OPM.RC,w:TXS.B,i:1},
	{n:'CLRB',md:OPM.RC,w:TXS.B},{n:'IVR',nm:'NOT',md:OPM.RC,w:TXS.B},
	{n:'SRRB',nm:'SRA',md:OPM.RC,w:TXS.B,i:1},{n:'SLRB',nm:'SLL',md:OPM.RC,w:TXS.B,i:1},
	{n:'RRRB',nm:'RORC',md:OPM.RC,w:TXS.B,i:1},{n:'RLRB',nm:'ROLC',md:OPM.RC,w:TXS.B,i:1},
	{n:'INAB',nm:'INC',md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'DCAB',nm:'DEC',md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'CLAB',nm:'CLR',md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'IVAB',nm:'NOT',md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'SRAB',nm:'SRA',md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'SLAB',nm:'SLL',md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'sX:',l:2,md:OPM.IMPL},
	{n:'dma.',md:OPM.IMPL,x:OPL_EXT.DMA}, // TODO
	// 0x3H
	{n:'INR',nm:'INC',md:OPM.RC,w:TXS.W,i:1},{n:'DCR',nm:'DEC',md:OPM.RC,w:TXS.W,i:1},
	{n:'CLR',md:OPM.RC,w:TXS.W},{n:'IVR',nm:'NOT',md:OPM.RC,w:TXS.W},
	{n:'SRR',nm:'SRA',md:OPM.RC,w:TXS.W,i:1},{n:'SLR',nm:'SLL',md:OPM.RC,w:TXS.W,i:1},
	{n:'RRR',nm:'RORC',md:OPM.RC,w:TXS.W,i:1},{n:'RLR',nm:'ROLC',md:OPM.RC,w:TXS.W,i:1},
	{n:'INA',nm:'INC',md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'DCA',nm:'DEC',md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'CLA',nm:'CLR',md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'IVA',nm:'NOT',md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'SRA',nm:'SRA',md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'SLA',nm:'SLL',md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'INX',nm:'INC',md:OPM.IMPL_R,w:TXS.W,dr:REG.X},
	{n:'DCX',nm:'DEC',md:OPM.IMPL_R,w:TXS.W,dr:REG.X},
	// 0x4H
	{n:'ADDB',md:OPM.RR,w:TXS.B},{n:'SUBB',md:OPM.RR,w:TXS.B},
	{n:'ANDB',md:OPM.RR,w:TXS.B},{n:'ORIB',nm:'OR',md:OPM.RR,w:TXS.B},
	{n:'OREB',nm:'XOR',md:OPM.RR,w:TXS.B},
	{n:'XFRB',nm:'MOV',md:OPM.RR,w:TXS.B},
	{n:'?X46',md:OPM.IMPL},{n:'?X47',md:OPM.IMPL},
	{n:'AABB',nm:'ADD',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.BL},
	{n:'SABB',nm:'SUB',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.BL},
	{n:'NABB',nm:'AND',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.BL},
	{n:'XAXB',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.XL},
	{n:'XAYB',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.YL},
	{n:'XABB',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.BL},
	{n:'XAZB',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.ZL},
	{n:'XASB',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.B,sr:REG.AL,dr:REG.SL},
	// 0x5H
	{n:'ADD',md:OPM.RRX,w:TXS.W},{n:'SUB',md:OPM.RRX,w:TXS.W},
	{n:'AND',md:OPM.RRX,w:TXS.W},{n:'ORI',nm:'OR',md:OPM.RRX,w:TXS.W},
	{n:'ORE',nm:'XOR',md:OPM.RRX,w:TXS.W},{n:'XFR',nm:'MOV',md:OPM.RRX,w:TXS.W},
	{n:'?X56',md:OPM.IMPL},{n:'?X57',md:OPM.IMPL},
	{n:'AAB',nm:'ADD',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.B},
	{n:'SAB',nm:'SUB',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.B},
	{n:'NAB',nm:'AND',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.B},
	{n:'XAX',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.X},
	{n:'XAY',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.Y},
	{n:'XAB',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.B},
	{n:'XAZ',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.Z},
	{n:'XAS',nm:'MOV',ms:OPM.IMPL_R,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.S},
	// 0x6H
	{n:'LDX',nm:'LD',ms:OPM.IMM,w:TXS.W,md:OPM.IMPL_R,dr:REG.X},
	{n:'LDX',nm:'LD',ms:OPM.DIR,w:TXS.W,md:OPM.IMPL_R,dr:REG.X},
	{n:'LDX',nm:'LD',ms:OPM.IND,w:TXS.W,md:OPM.IMPL_R,dr:REG.X},
	{n:'LDX',nm:'LD',ms:OPM.PCO,w:TXS.W,md:OPM.IMPL_R,dr:REG.X},
	{n:'LDX',nm:'LD',ms:OPM.IPO,w:TXS.W,md:OPM.IMPL_R,dr:REG.X},
	{n:'LDX',nm:'LD',ms:OPM.MOD,w:TXS.W,md:OPM.IMPL_R,dr:REG.X},
	{n:'?X66',md:OPM.IMPL},{n:'?X67',md:OPM.IMPL},
	{n:'STX',nm:'ST',md:OPM.IMM,ms:OPM.IMPL_R,w:TXS.W,sr:REG.X},
	{n:'STX',nm:'ST',md:OPM.DIR,ms:OPM.IMPL_R,w:TXS.W,sr:REG.X},
	{n:'STX',nm:'ST',md:OPM.IND,ms:OPM.IMPL_R,w:TXS.W,sr:REG.X},
	{n:'STX',nm:'ST',md:OPM.PCO,ms:OPM.IMPL_R,w:TXS.W,sr:REG.X},
	{n:'STX',nm:'ST',md:OPM.IPO,ms:OPM.IMPL_R,w:TXS.W,sr:REG.X},
	{n:'STX',nm:'ST',md:OPM.MOD,ms:OPM.IMPL_R,w:TXS.W,sr:REG.X},
	{n:'?X6E',md:OPM.IMPL},{n:'?X6F',md:OPM.IMPL},
	// 0x7H
	{n:'JMP',md:OPM.IMM,w:TXS.F},{n:'JMP',md:OPM.DIR,w:TXS.F},
	{n:'JMP',md:OPM.IND,w:TXS.F},{n:'JMP',md:OPM.PCO,w:TXS.F},
	{n:'JMP',md:OPM.IPO,w:TXS.F},{n:'JMP',md:OPM.MOD,w:TXS.F},
	{n:'?SYSCALL',md:OPM.IMPL},
	{n:'?X77',md:OPM.RRX,w:TXS.F},
	{n:'JSR',nm:'CALL',md:OPM.RRX,w:TXS.F},{n:'JSR',nm:'CALL',md:OPM.DIR,w:TXS.F},
	{n:'JSR',nm:'CALL',md:OPM.IND,w:TXS.F},{n:'JSR',nm:'CALL',md:OPM.PCO,w:TXS.F},
	{n:'JSR',nm:'CALL',md:OPM.IPO,w:TXS.F},{n:'JSR',nm:'CALL',md:OPM.MOD,w:TXS.F},
	{n:'?X7E',md:OPM.IMPL,x:OPL_EXT.MPUSH},
	{n:'?X7F',md:OPM.IMPL,x:OPL_EXT.MPOP},
	// 0x8H
	{n:'LDAB',nm:'LD',ms:OPM.IMM,md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'LDAB',nm:'LD',ms:OPM.DIR,md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'LDAB',nm:'LD',ms:OPM.IND,md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'LDAB',nm:'LD',ms:OPM.PCO,md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'LDAB',nm:'LD',ms:OPM.IPO,md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'LDAB',nm:'LD',ms:OPM.MOD,md:OPM.IMPL_R,w:TXS.B,dr:REG.AL},
	{n:'?sy86',md:OPM.IMPL},
	{n:'?X87',md:OPM.IMPL},
	{n:'LAAB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.A,dr:REG.AL},
	{n:'LABB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.B,dr:REG.AL},
	{n:'LAXB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.X,dr:REG.AL},
	{n:'LAYB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.Y,dr:REG.AL},
	{n:'LAZB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.Z,dr:REG.AL},
	{n:'LASB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.S,dr:REG.AL},
	{n:'LACB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.C,dr:REG.AL},
	{n:'LAPB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.PC,dr:REG.AL},
	// 0x9H
	{n:'LDA',nm:'LD',ms:OPM.IMM,md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'LDA',nm:'LD',ms:OPM.DIR,md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'LDA',nm:'LD',ms:OPM.IND,md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'LDA',nm:'LD',ms:OPM.PCO,md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'LDA',nm:'LD',ms:OPM.IPO,md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'LDA',nm:'LD',ms:OPM.MOD,md:OPM.IMPL_R,w:TXS.W,dr:REG.A},
	{n:'?sy96',md:OPM.IMPL},
	{n:'?s9-97',md:OPM.IMPL},
	{n:'LAA',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.A},
	{n:'LAB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.B,dr:REG.A},
	{n:'LAX',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.X,dr:REG.A},
	{n:'LAY',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.Y,dr:REG.A},
	{n:'LAZ',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.Z,dr:REG.A},
	{n:'LAS',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.S,dr:REG.A},
	{n:'LAC',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.C,dr:REG.A},
	{n:'LAP',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.PC,dr:REG.A},
	// 0xAH
	{n:'STAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMM,w:TXS.B,sr:REG.AL},
	{n:'STAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.DIR,w:TXS.B,sr:REG.AL},
	{n:'STAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IND,w:TXS.B,sr:REG.AL},
	{n:'STAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.PCO,w:TXS.B,sr:REG.AL},
	{n:'STAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IPO,w:TXS.B,sr:REG.AL},
	{n:'STAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.MOD,w:TXS.B,sr:REG.AL},
	{n:'?XA6',md:OPM.IMPL},
	{n:'?XA7',md:OPM.IMPL},
	{n:'SAAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.A},
	{n:'SABB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.B},
	{n:'SAXB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.X},
	{n:'SAYB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.Y},
	{n:'SAZB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.Z},
	{n:'SASB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.S},
	{n:'SACB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.C},
	{n:'SAPB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.AL,dr:REG.PC},
	// 0xBH
	{n:'STA',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMM,w:TXS.W,sr:REG.A},
	{n:'STA',nm:'ST',ms:OPM.IMPL_R,md:OPM.DIR,w:TXS.W,sr:REG.A},
	{n:'STA',nm:'ST',ms:OPM.IMPL_R,md:OPM.IND,w:TXS.W,sr:REG.A},
	{n:'STA',nm:'ST',ms:OPM.IMPL_R,md:OPM.PCO,w:TXS.W,sr:REG.A},
	{n:'STA',nm:'ST',ms:OPM.IMPL_R,md:OPM.IPO,w:TXS.W,sr:REG.A},
	{n:'STA',nm:'ST',ms:OPM.IMPL_R,md:OPM.MOD,w:TXS.W,sr:REG.A},
	{n:'?syB6',md:OPM.IMPL},
	{n:'?s9-B7',md:OPM.IMPL},
	{n:'SAA',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.A},
	{n:'SAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.B},
	{n:'SAX',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.X},
	{n:'SAY',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.Y},
	{n:'SAZ',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.Z},
	{n:'SAS',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.S},
	{n:'SAC',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.C},
	{n:'SAP',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.A,dr:REG.PC},
	// 0xCH
	{n:'LDBB',nm:'LD',ms:OPM.IMM,md:OPM.IMPL_R,w:TXS.B,dr:REG.BL},
	{n:'LDBB',nm:'LD',ms:OPM.DIR,md:OPM.IMPL_R,w:TXS.B,dr:REG.BL},
	{n:'LDBB',nm:'LD',ms:OPM.IND,md:OPM.IMPL_R,w:TXS.B,dr:REG.BL},
	{n:'LDBB',nm:'LD',ms:OPM.PCO,md:OPM.IMPL_R,w:TXS.B,dr:REG.BL},
	{n:'LDBB',nm:'LD',ms:OPM.IPO,md:OPM.IMPL_R,w:TXS.B,dr:REG.BL},
	{n:'LDBB',nm:'LD',ms:OPM.MOD,md:OPM.IMPL_R,w:TXS.B,dr:REG.BL},
	{n:'?syC6',md:OPM.IMPL},
	{n:'?s9-C7',md:OPM.IMPL},
	{n:'LBAB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.A,dr:REG.BL},
	{n:'LBBB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.B,dr:REG.BL},
	{n:'LBXB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.X,dr:REG.BL},
	{n:'LBYB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.Y,dr:REG.BL},
	{n:'LBZB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.Z,dr:REG.BL},
	{n:'LBSB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.S,dr:REG.BL},
	{n:'LBCB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.C,dr:REG.BL},
	{n:'LBPB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.B,sr:REG.PC,dr:REG.BL},
	// 0xDH
	{n:'LDB',nm:'LD',ms:OPM.IMM,md:OPM.IMPL_R,w:TXS.W,dr:REG.B},
	{n:'LDB',nm:'LD',ms:OPM.DIR,md:OPM.IMPL_R,w:TXS.W,dr:REG.B},
	{n:'LDB',nm:'LD',ms:OPM.IND,md:OPM.IMPL_R,w:TXS.W,dr:REG.B},
	{n:'LDB',nm:'LD',ms:OPM.PCO,md:OPM.IMPL_R,w:TXS.W,dr:REG.B},
	{n:'LDB',nm:'LD',ms:OPM.IPO,md:OPM.IMPL_R,w:TXS.W,dr:REG.B},
	{n:'LDB',nm:'LD',ms:OPM.MOD,md:OPM.IMPL_R,w:TXS.W,dr:REG.B},
	{n:'?XD6',md:OPM.IMPL},
	{n:'?syD7',md:OPM.IMPL},
	{n:'LBA',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.A,dr:REG.B},
	{n:'LBB',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.B,dr:REG.B},
	{n:'LBX',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.X,dr:REG.B},
	{n:'LBY',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.Y,dr:REG.B},
	{n:'LBZ',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.Z,dr:REG.B},
	{n:'LBS',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.S,dr:REG.B},
	{n:'LBC',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.C,dr:REG.B},
	{n:'LBP',nm:'LD',ms:OPM.IMPL_R_DIR,md:OPM.IMPL_R,w:TXS.W,sr:REG.PC,dr:REG.B},
	// 0xEH
	{n:'STBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMM,w:TXS.B,sr:REG.BL},
	{n:'STBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.DIR,w:TXS.B,sr:REG.BL},
	{n:'STBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IND,w:TXS.B,sr:REG.BL},
	{n:'STBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.PCO,w:TXS.B,sr:REG.BL},
	{n:'STBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IPO,w:TXS.B,sr:REG.BL},
	{n:'STBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.MOD,w:TXS.B,sr:REG.BL},
	{n:'?syE6',md:OPM.IMPL},
	{n:'?s9-E7',md:OPM.IMPL},
	{n:'SBAB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.A},
	{n:'SBBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.B},
	{n:'SBXB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.X},
	{n:'SBYB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.Y},
	{n:'SBZB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.Z},
	{n:'SBSB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.S},
	{n:'SBCB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.C},
	{n:'SBPB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.B,sr:REG.BL,dr:REG.PC},
	// 0xFH
	{n:'STB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMM,w:TXS.W,sr:REG.B},
	{n:'STB',nm:'ST',ms:OPM.IMPL_R,md:OPM.DIR,w:TXS.W,sr:REG.B},
	{n:'STB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IND,w:TXS.W,sr:REG.B},
	{n:'STB',nm:'ST',ms:OPM.IMPL_R,md:OPM.PCO,w:TXS.W,sr:REG.B},
	{n:'STB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IPO,w:TXS.W,sr:REG.B},
	{n:'STB',nm:'ST',ms:OPM.IMPL_R,md:OPM.MOD,w:TXS.W,sr:REG.B},
	{n:'?syF6',md:OPM.IMPL,l:3}, // TODO
	{n:'?XF7',md:OPM.IMPL},
	{n:'SBA',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.A},
	{n:'SBB',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.B},
	{n:'SBX',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.X},
	{n:'SBY',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.Y},
	{n:'SBZ',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.Z},
	{n:'SBS',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.S},
	{n:'SBC',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.C},
	{n:'SBP',nm:'ST',ms:OPM.IMPL_R,md:OPM.IMPL_R_DIR,w:TXS.W,sr:REG.B,dr:REG.PC},
];

interface AnnotationLine {
	address:number;
	comm?:string[];
	pre?:string[];
	label?:string[];
	data?:string;
}
const annotation_data = new Map<number, AnnotationLine>();

function annotation_import(src:string) {
	const lines = src.replace("\r", "").split(/\n/);
	const scan = {
		ws: /^[ \t\r\n]+/,
		num: /^0x[0-9a-fA-F]+/,
		punct: /^[,:]+/,
		comm: /^;.*$/,
		word: /^[A-Za-z_$@][A-Za-z0-9_$@]*/,
		ign: /^[>][A-Za-z0-9_$@]*/,
	}
	const defer = new Set<string>([
		'comment','pre','plate','plate_comment','pre_comment',
		'label','code'
	]);
	annotation_data.clear();
	let anno_lines = [];
	let prev_line:AnnotationLine | null = null;
	for (let line of lines) {
		let parse:AnnotationLine = {address:-1};
		let offset = 0;
		let cmd_state:string | null = null;
		while (offset < line.length) {
			let fragment = line.substring(offset);
			let res:RegExpExecArray | null;
			let test = function(v:RegExp):RegExpExecArray | null {
				let ires = v.exec(fragment);
				if (ires != null && ires.length > 0 && ires[0].length > 0) {
					offset += ires[0].length;
					return ires;
				} else {
					return null;
				}
			}
			if (test(scan.ws)) {
			} else if (test(scan.punct)) {
			} else if (res = test(scan.num)) {
				parse.address = parseInt(res[0]);
			} else if (res = test(scan.comm)) {
				if (cmd_state != null && (
					cmd_state == 'pre_comment' ||
					cmd_state == 'pre' ||
					cmd_state == 'plate' ||
					cmd_state == 'plate_comment' ||
					cmd_state == 'pre_comment'))
				{
					if (parse.address == -1 && prev_line != null) {
						if (prev_line.pre == undefined) {
							prev_line.pre = [res[0]];
						} else {
							prev_line.pre.push(res[0]);
						}
					} else {
						parse.pre = [res[0]];
					}
				} else {
					if (parse.address == -1 && prev_line != null) {
						if (prev_line.comm == undefined){
							prev_line.comm = [res[0]];
						} else {
							prev_line.comm.push(res[0]);
						}
					} else {
						parse.comm = [res[0]];
					}
				}
			} else if (res = test(scan.word)) {
				let cmd = res[0].toLowerCase();
				if (cmd_state != null) {
					if (cmd_state == 'label' || cmd_state == 'code') {
						parse.label = [res[0]];
					} else if (cmd_state == 'comment') {
						parse.comm = [res[0]];
					} else if (
						cmd_state == 'pre_comment' ||
						cmd_state == 'pre' ||
						cmd_state == 'plate' ||
						cmd_state == 'plate_comment' ||
						cmd_state == 'pre_comment') {
						parse.pre = [res[0]];
					} else {
					}
					cmd_state = null;
				} else if (defer.has(cmd)) {
					cmd_state = cmd;
				} else if (cmd == 'pstring16') {
					parse.data = 'pstringhi';
				} else {
					console.warn('unhandled:', cmd);
				}
			} else if (res = test(scan.ign)) {
				if (res[0] == '>H') {
					parse.data = 'word';
				} else if (res[0] == '>B') {
					parse.data = 'byte';
				}
			} else {
				console.warn('input invalid');
			}
		}
		if (parse.address != -1) {
			anno_lines.push(parse);
			prev_line = parse;
			let last = annotation_data.get(parse.address);
			if (last == undefined) {
				annotation_data.set(parse.address, parse);
			} else {
				if(parse.pre != null) {
					if (last.pre != null) last.pre.push(...parse.pre);
					else last.pre = parse.pre;
				}
				if(parse.comm != null) {
					if (last.comm != null) last.comm.push(...parse.comm);
					else last.comm = parse.comm;
				}
				if (parse.label != null) {
					if (last.label != null) last.label.push(...parse.label);
					else last.label = parse.label;
				}
				if (parse.data != null) {
					if (last.data != null) console.error('redefinition of data');
					else last.data = parse.data;
				}
			}
		}
	}
}

interface DisAsmResult {
	t:string,
	l:number,
	pre?:string,
	post?:string
}

class CPU6 {

	// backing buffers
	register_buffer = new ArrayBuffer(256);
	page_buffer = new ArrayBuffer(256);
	// the system registers in various interrupt levels
	register_file = new DataView(this.register_buffer);
	// memory management
	page_file = new DataView(this.page_buffer);
	// global registers
	reg_s:number = 0;
	reg_p:number = 0x100;
	reg_c:number = 0; // context


	// TODO backplane
	mem: Backplane;
	constructor(m: Backplane) {
		this.mem = m;
	}

	// load an instruction byte from the memory sub-system
	// TODO address routing, MMIO
	fetch(addr:number) {
		return this.mem.readbyte(addr);
	}

	disassembly(address:number) {
		const DREF_L = NAME_CONV == 1 ? '[' : '(';
		const DREF_R = NAME_CONV == 1 ? ']' : ')';
		const DDREF_L = DREF_L + DREF_L;
		const DDREF_R = DREF_R + DREF_R;
		let vpc = address;
		if (this.mem.is_mmio(vpc)) {
			return {t:'??', l:1};
		}
		let op = this.fetch(vpc++);
		let dstr = '';

		let opcs = oplist[op];
		let anpre = '';
		let anstr = '';
		let opname = opcs.n;
		let anno_data = '';
		dstr += `${hex(op)}`;
		function check_anno(a:number) {
			let anno = annotation_data.get(a);
			if (anno) {
				if (anno.pre != null) {
					for (let com of anno.pre) {
						anpre += `<div class="cmm">${com}</div>`;
					}
				}
				if (anno.comm != null) {
					for (let com of anno.comm) {
						anstr += `<div class="cmm">${com}</div>`;
					}
				}
				if (anno.label && anno.label.length > 0) {
					anpre += `<div class="sym">${anno.label[0]}:</div>`;
				}
				if (anno.data != null) {
					anno_data = anno.data;
					//throw {is_data:true, data_class:anno.data};
				}
			}
		}
		
		function is_hiascii(v:number):boolean {
			return (v > 0x9f && v < 0xff) || (v == 0x89) || (v == 0x8a) || (v == 0x8c) || (v == 0x8d);
		}
		function ascenc(v:number):string {
			let vasc = v & 0x7f;
			let rcp;
			if (vasc > 0x20 && vasc < 0x7f) {
				rcp = String.fromCodePoint(vasc);
			} else if (vasc == 32) {
				rcp = NB;
			} else if (vasc == 9) {
				rcp = "\u2192";
			} else if (vasc == 10) {
				rcp = "\u2193";
			} else if (vasc == 12) {
				rcp = "\u21ca";
			} else if (vasc == 13) {
				rcp = "\u21b5";
			} else {
				rcp = "\u2588";
			}
			return rcp;
		}
		function addrrefw(a:number):string {
			if (mmwlist.has(a)) {
				return `${hexlist(a, 4)} &lt;${mmwlist.get(a)}>`;
			} else {
				let anno = annotation_data.get(a);
				if (anno && anno.label && anno.label.length > 0) {
					return `${hexlist(a, 4)} &lt;${anno.label[0]}>`;
				}
				return hexlist(a, 4);
			}
		}
		function addrref(a:number):string {
			a &= 0xffff;
			if (mmiolist.has(a)) {
				return `${hexlist(a, 4)} &lt;${mmiolist.get(a)}>`;
			} else {
				let anno = annotation_data.get(a);
				if (anno && anno.label && anno.label.length > 0) {
					return `${hexlist(a, 4)} &lt;${anno.label[0]}>`;
				}
				return hexlist(a, 4);
			}
		}
		let astr = ascenc(op);
		let dfetch = ()=> {
			check_anno(vpc);
			let rv = this.fetch(vpc++);
			dstr += ` ${hex(rv)}`;
			astr += ascenc(rv);
			return rv;
		}
		let psstr = '';
		let pstr = '';

		check_anno(address);
		if (anno_data == 'byte') {
			
			dstr = `${dstr.padEnd(12, NB)}${astr.padEnd(4, NB)} .byte ${hexlist(op, 2)}`;
			const ret:DisAsmResult = {t:dstr, l:vpc - address};
			if (anpre.length > 0) ret.pre = anpre;
			if (anstr.length > 0) ret.post = anstr;
			return ret;
		} else if (anno_data == 'word') {
			let vl = dfetch();
			dstr = `${dstr.padEnd(12, NB)}${astr.padEnd(4, NB)} .word ${hexlist((op << 8) | vl, 4)}`;
			const ret:DisAsmResult = {t:dstr, l:vpc - address};
			if (anpre.length > 0) ret.pre = anpre;
			if (anstr.length > 0) ret.post = anstr;
			return ret;
		}
		let vstr = '';
		if (op == 0 && this.fetch(vpc) > 3) { // TODO does not cover long strings!
			let vstart = vpc + 1;
			let vpcs = vstart;
			let pre = this.fetch(vpc);
			//check_anno(vpc);
			//check_anno(vpcs);
			let f = this.fetch(vpcs++);
			let slen = 0;
			let nonspace = false;
			while(is_hiascii(f)) {
				slen = (vpcs - vstart);
				if (slen > 160) break;
				if (f == 0x89) {
					vstr += '\\t';
				} else if (f == 0x8a) {
					vstr += '\\n';
				} else if (f == 0x8d) {
					vstr += '\\r';
				} else {
					vstr += ascenc(f);
					if (f != 0xa0) nonspace = true;
				}
				if (pre == slen && slen >= 2 && nonspace) {
					// pascal string
					const ret:DisAsmResult = {t:`<span class="pstr">.npstringhi "${vstr}"</span>`, l:vpcs - address};
					if (anpre.length > 0) {
						ret.pre = anpre;
					}
					if (anstr.length > 0) {
						ret.post = anstr;
					}
					return ret;
				}
				//check_anno(vpcs);
				f = this.fetch(vpcs++);
			}
			slen = (vpcs - vpc);
			if (pre == slen && slen >= 2 && nonspace) {
				// pascal string
				vpcs--;
				const ret:DisAsmResult = {t:`<span class="pstr">.npstringhi "${vstr}"</span>`, l:vpcs - address};
				if (anpre.length > 0) {
					ret.pre = anpre;
				}
				if (anstr.length > 0) {
					ret.post = anstr;
				}
				return ret;
			}
			if (!nonspace) {
				vstr = '';
			}
		} else if (is_hiascii(op)) {
			let vpcs = vpc - 1;
			let pre = (this.fetch(vpc - 3) << 8) | this.fetch(vpc - 2);
			let f = this.fetch(vpcs++);
			let slen = 0;
			vstr = '';
			let nonspace = false;
			while(is_hiascii(f)) {
				if ((vpcs - vpc) > 160) break;
				if (f == 0x89) {
					vstr += '\\t';
				} else if (f == 0x8a) {
					vstr += '\\n';
				} else if (f == 0x8d) {
					vstr += '\\r';
				} else {
					vstr += ascenc(f);
					if (f != 0xa0) nonspace = true;
				}
				slen = (vpcs - vpc);
				if (pre == slen && slen >= 2 && nonspace) {
					// pascal string
					const ret:DisAsmResult = {t:`<span class="pstr">.pstringhi "${vstr}"</span>`, l:vpcs - address};
					if (anpre.length > 0) {
						ret.pre = anpre;
					}
					if (anstr.length > 0) {
						ret.post = anstr;
					}
					return ret;
				}
				//check_anno(vpcs);
				f = this.fetch(vpcs++);
			}
			slen = (vpcs - vpc);
			if (pre == slen && slen >= 2 && nonspace) {
				// pascal string
				vpcs--;
				const ret:DisAsmResult = {t:`<span class="pstr">.pstringhi "${vstr}"</span>`, l:vpcs - address};
				if (anpre.length > 0) {
					ret.pre = anpre;
				}
				if (anstr.length > 0) {
					ret.post = anstr;
				}
				return ret;
			} else if(f == 0 && slen > 3 && nonspace) {
				// zstring/cstring
				const ret:DisAsmResult = {t:`<span class="zstr">.zstringhi "${vstr}"</span>`, l:vpcs - address};
				if (anpre.length > 0) {
					ret.pre = anpre;
				}
				if (anstr.length > 0) {
					ret.post = anstr;
				}
				return ret;
			}
			if (!nonspace) {
				vstr = '';
			}
		}
		
		let r = 1;
		if (opcs.l !== undefined) {
			while(r < opcs.l) {
				dfetch();
				r++;
			}
		}
		
		let rsh = 0;
		if (opcs.w == TXS.W) {
			rsh = 16;
		}
		function decode_mode(mode:OPM, is_write:boolean, regm?:REG):string {
			let disp;
			let rvc;
			let advh, advl, adr;
			switch(mode) {
			case OPM.IMPL: return '';
			case OPM.IMM:
				if (opcs.w == TXS.B) {
					return (is_write?'>#':'#') + hexlist(dfetch());
				}
				if (opcs.w == TXS.W) {
					let hi = dfetch();
					let lo = dfetch();
					return (is_write?'>#':'#') + hexlist((hi << 8) | lo, 4);
				}
				return (is_write?'>#':'#') + '&lt;invalid&gt;';
			case OPM.DIR:
				advh = dfetch();
				advl = dfetch();
				adr = (advh << 8) | advl;
				switch (opcs.w) {
				case TXS.F: return `:${addrref(adr)}`;
				case TXS.B: return `${DREF_L}${addrref(adr)}${DREF_R}`;
				case TXS.W: return `${DREF_L}${addrrefw(adr)}${DREF_R}`;
				}
				return '#&lt;invalid&gt;';
			case OPM.IND:
				advh = dfetch();
				advl = dfetch();
				adr = (advh << 8) | advl;
				if (opcs.w == TXS.F) {
					return ':' + DREF_L + addrref(adr) + DREF_R;
				}
				return DDREF_L + addrref(adr) + DDREF_R;
			case OPM.PCO:
				disp = sbyte(dfetch());
				if (opcs.w == TXS.F) {
					return 'PC' + (disp<0?'':'+') + hexlist(disp) + ' \u21d2 ' + addrrefw(vpc + disp);
				} else if (opcs.w == TXS.W) {
					return DREF_L + 'PC' + (disp<0?'':'+') + hexlist(disp) + ' \u21d2 ' + addrrefw(vpc + disp) + DREF_R;
				}
				return DREF_L + 'PC' + (disp<0?'':'+') + hexlist(disp) + ' \u21d2 ' + addrref(vpc + disp) + DREF_R;
			case OPM.IPO:
				disp = sbyte(dfetch());
				if (opcs.w == TXS.F) {
					return 'PC' + (disp<0?'':'+') + hexlist(disp) + ' \u21d2 ' + DREF_L + addrrefw(vpc + disp) + DREF_R;
				} else if (opcs.w == TXS.W) {
					return DREF_L + ' PC' + (disp<0?'':'+') + hexlist(disp) + ' \u21d2 ' + DREF_L + addrrefw(vpc + disp) + DREF_R + ' ' + DREF_R;
				}
				return DREF_L + ' PC' + (disp<0?'':'+') + hexlist(disp) + ' \u21d2 ' + DREF_L + addrref(vpc + disp) + DREF_R + ' ' + DREF_R;
			case OPM.MOD:
				rvc = dfetch();
				let modv = rvc & 15;
				disp = 0;
				if ((modv & 8) > 0) {
					disp = sbyte(dfetch());
				}
				let res = regname[16 + (rvc >> 4)];
				if ((modv & 3) == 2){
					res = '--' + res;
				} else if ((modv & 3) == 1) {
					res = res + '++';
				}
				if ((modv & 8) > 0) {
					res = `${res} ${disp<0?'-':'+'} ${hexlist(disp<0?-disp:disp)}`;
				}
				res = `${DREF_L}${res}${DREF_R}`;
				if ((modv & 4) > 0) {
					res = `${DREF_L}${res}${DREF_R}`;
				}
				return res;
			case OPM.RR:
			case OPM.RRX:
			case OPM.RC:
				if(!is_write) throw new Error('RR/RC in source operand, should be in dest');
				rvc = dfetch();
				let regdst = (rvc >> 4);
				let regsrc = (rvc & 15);
				let rrxmode = ((regdst & 1) << 1) | (regsrc & 1);
				if (opcs.md == OPM.RRX && rrxmode > 0) {
					// nibbles mismatch
					advh = dfetch();
					advl = dfetch();
					adr = (advh << 8) | advl;
					if (rrxmode == 1) {
						// MSN even
						return regname[rsh + regdst] + `:&lt;${regname[rsh + regsrc]}> + ${DREF_L}${addrref(adr)}${DREF_R}`;
					} else if (rrxmode == 2) {
						// MSN odd
						return regname[rsh + regdst] + `:&lt;${regname[rsh + regsrc]}> + ${hexlist(adr, 4)}`;
					} else {
						return regname[rsh + regdst] + `:${DREF_L}&lt;${regname[rsh + regsrc]}> + ${addrref(adr)}${DREF_R}`;
					}
				} else if (opcs.md == OPM.RR || opcs.md == OPM.RRX) {
					return regname[rsh + regdst] + ',' + regname[rsh + regsrc];
				} else if (opcs.i != undefined) {
					return regname[rsh + regdst] + ',' + hexlist(regsrc + opcs.i, 1);
				} else {
					return regname[rsh + regdst] + ',' + hexlist(regsrc, 1);
				}
			case OPM.IMPL_R:
				if (NAME_CONV != 1) {
					return '';
				}
				if (regm != undefined) {
					return regname[rsh + regm];
				} else {
					return '!R';
				}
			case OPM.IMPL_R_DIR:
				if (NAME_CONV != 1) {
					return '';
				}
				if (regm != undefined) {
					return `${DREF_L}${regname[16 + regm]}${DREF_R}`;
				} else {
					return `${DREF_L}!R${DREF_R}`;
				}
			}
		}
		if (opcs.ms != null) {
			psstr = decode_mode(opcs.ms, false, opcs.sr);
		}
		pstr = decode_mode(opcs.md, true, opcs.dr);

		let rvc;
		switch(opcs.x) {
		case undefined:
			break;
		case OPL_EXT.MPUSH:
		case OPL_EXT.MPOP:
			rvc = dfetch();
			{
				if (opcs.x == OPL_EXT.MPOP) {
					opname = 'MPOP';
				} else {
					opname = 'MPUSH';
				}
				let rstart = (rvc >> 4);
				let rcount = (rvc & 15);
				pstr = regname[rstart++];
				while(rcount > 0) {
					pstr += ',' + regname[rstart++];
					rcount--;
				}
			}
			break;
		case OPL_EXT.DMA:
			rvc = dfetch();
			let reg = (rvc >> 4);
			let sel = (rvc & 15);
			switch(sel) {
			case 0: opname = (NAME_CONV == 1) ? opname + 'WR.A' : 'LDDMAA';
				pstr = regname[16 + reg];
				break;
			case 1: opname = (NAME_CONV == 1) ? opname +'RD.A' : 'STDMAA';
				psstr = regname[16 + reg];
				break;
			case 2: opname = (NAME_CONV == 1) ? opname +'WR.C' : 'LDDMAC';
				pstr = regname[16 + reg];
				break;
			case 3: opname = (NAME_CONV == 1) ? opname +'RD.C' : 'STDMAC';
				psstr = regname[16 + reg];
				break;
			case 4:
				opname = (NAME_CONV == 1) ? opname +'WR.M' : 'SETDMAM';
				psstr = `#${hexlist(reg,1)}`;
				break;
			case 5:
				opname = (NAME_CONV == 1) ? opname +'WR.M' : 'SETDMAMR';
				psstr = regname[16 + reg];
				break;
			case 6:
				opname = (NAME_CONV == 1) ? opname +'EN' : 'EDMA';
				break;
			case 7:
				opname = (NAME_CONV == 1) ? opname +'DIS' : 'DDMA';
				break;
			case 8:
				opname = (NAME_CONV == 1) ? opname +'WR.S' : 'LDISR';
				psstr = regname[16 + reg];
				break;
			case 9:
				opname = (NAME_CONV == 1) ? opname +'RD.S' : 'STISR';
				pstr = regname[16 + reg];
				break;
			default:
				opname += hex(sel, 1);
			}
			break;
		}
		
		if (NAME_CONV == 1 && opcs.nm !== undefined) {
			opname = opcs.nm;
		}
		if (pstr.length > 0 && psstr.length > 0) {
			pstr += ', ';
		}
		dstr = `${dstr.padEnd(12, NB)}${astr.padEnd(4, NB)} ${opname} ${pstr}${psstr}`;
		if (vstr.length > 5) {
			dstr += ` ;; "${vstr}"`;
		}
		
		const ret:DisAsmResult = {t:dstr, l:vpc - address};
		if (anpre.length > 0) {
			ret.pre = anpre;
		}
		if (anstr.length > 0) {
			ret.post = anstr;
		}
		return ret;
	}
	// emulation of instructions at a high level
	softstep() {
		let op = this.fetch(this.reg_p);

	}
}


const diag1 = new ROM2k();
const diag2 = new ROM2k();
const diag3 = new ROM2k();
const diag4 = new ROM2k();
diag1.loadbin(diag.f1);
diag2.loadbin(diag.f2);
diag3.loadbin(diag.f3);
diag4.loadbin(diag.f4);
const mmio_mux = new MMIOMux();
const mem = [
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
	new SysMem(), new SysMem(), new SysMem(), new SysMem(),
];
bpl.configmemory(0x3fc00, new ROM512({
	bin:bpl_rom, addr:{invert:true, remap:[0,1,2,3,4,8,5,6,7]},
	//hex:'90 C0 00 5F 90 88 00 5E 71 88 49' // force ins test
}), 512);
bpl.configmemory(0x3f200, mmio_mux, 256);
cx_crt0.mux = mmio_mux.muxports[0];
bpl.configio(1, dsk2_0);
bpl.configio(0, mmio_mux);
bpl.configmemory(0x3f100, new MMIOMulti(), 256);
for(let q = 0; q < 32; q++) {
	//if (q >= 8 && q < 10) continue;
	bpl.configmemory(q * 0x1000, mem[q], 4096);
}
// bpl.configmemory(0x8000, diag1, 2048);
// bpl.configmemory(0x8800, diag2, 2048);
// bpl.configmemory(0x9000, diag3, 2048);
// bpl.configmemory(0x9800, diag4, 2048);
//bpl.configmemory(0xb800, new RAM2k(), 2048);
const cpu = new CPU6(bpl);

mem[0].loadhex(program_rotr, 0x100);
//mem.loadbin(wipl_dump);

function show_disasm() {
	let vpc = dis_vpc;
	for (let i = 0; i < listmax; i++) {
		try {
			let res = cpu.disassembly(vpc);
			listing[i].innerHTML = `${res.pre ? res.pre : ''}<div class="line"><span>${hex(vpc, 5)}: ${res.t}</span><div>${res.post ? res.post : ''}</div></div>`;
			vpc = (vpc + res.l) & 0x3ffff;
		} catch(e) {
			listing[i].innerHTML = `<div class="line"><span>${hex(vpc, 5)}: {{ERROR}}</span></div>`;
			vpc += 1;
		}
	}
	dis_vpc_end = vpc;
}
in_dbgcmd.addEventListener('input', function(ev) {
	if (this.value.search(/^[0-9a-fA-F]{1,5}$/) > -1) {
		dis_vpc = parseInt(this.value, 16) & 0x3ffff;
		show_disasm();
	}
});
in_dbgcmd.addEventListener('keypress', function(ev) {
	if (ev.code == 'Enter' || ev.code == 'NumpadEnter') {
	}
});
// sense_switch
function update_sense() {
	if ((sense_switch & 1) > 0) {
		btn_ss1.classList.add('active');
	} else {
		btn_ss1.classList.remove('active');
	}
	if ((sense_switch & 2) > 0) {
		btn_ss2.classList.add('active');
	} else {
		btn_ss2.classList.remove('active');
	}
	if ((sense_switch & 4) > 0) {
		btn_ss3.classList.add('active');
	} else {
		btn_ss3.classList.remove('active');
	}
	if ((sense_switch & 8) > 0) {
		btn_ss4.classList.add('active');
	} else {
		btn_ss4.classList.remove('active');
	}
}
function update_diagsw() {
	if ((cx_diag0.dip & 1) > 0) {
		btn_dt1.classList.add('active');
	} else {
		btn_dt1.classList.remove('active');
	}
	if ((cx_diag0.dip & 2) > 0) {
		btn_dt2.classList.add('active');
	} else {
		btn_dt2.classList.remove('active');
	}
	if ((cx_diag0.dip & 4) > 0) {
		btn_dt4.classList.add('active');
	} else {
		btn_dt4.classList.remove('active');
	}
	if ((cx_diag0.dip & 8) > 0) {
		btn_dt8.classList.add('active');
	} else {
		btn_dt8.classList.remove('active');
	}
}
update_sense();
update_diagsw();
btn_ss1.addEventListener('click', function(ev) {
	sense_switch ^= 1;
	update_sense();
});
btn_ss2.addEventListener('click', function(ev) {
	sense_switch ^= 2;
	update_sense();
});
btn_ss3.addEventListener('click', function(ev) {
	sense_switch ^= 4;
	update_sense();
});
btn_ss4.addEventListener('click', function(ev) {
	sense_switch ^= 8;
	update_sense();
});
btn_dt1.addEventListener('click', function(ev) {
	cx_diag0.dip ^= 1;
	update_diagsw();
});
btn_dt2.addEventListener('click', function(ev) {
	cx_diag0.dip ^= 2;
	update_diagsw();
});
btn_dt4.addEventListener('click', function(ev) {
	cx_diag0.dip ^= 4;
	update_diagsw();
});
btn_dt8.addEventListener('click', function(ev) {
	cx_diag0.dip ^= 8;
	update_diagsw();
});
btn_dtrun.addEventListener('click', function(ev) {
	cx_diag0.dip ^= 0x10;
});
btn_or0.addEventListener('click', function(ev) {
	mcstate.override_or ^= 1;
	if ((mcstate.override_or & 1) > 0) {
		this.classList.add('active');
	} else {
		this.classList.remove('active');
	}
});
btn_or1.addEventListener('click', function(ev) {
	mcstate.override_or ^= 2;
	if ((mcstate.override_or & 2) > 0) {
		this.classList.add('active');
	} else {
		this.classList.remove('active');
	}
});
btn_or2.addEventListener('click', function(ev) {
	mcstate.override_or ^= 4;
	if ((mcstate.override_or & 4) > 0) {
		this.classList.add('active');
	} else {
		this.classList.remove('active');
	}
});
btn_or3.addEventListener('click', function(ev) {
	mcstate.override_or ^= 8;
	if ((mcstate.override_or & 8) > 0) {
		this.classList.add('active');
	} else {
		this.classList.remove('active');
	}
});
reset_button.addEventListener('click', function(ev) {
	mcreset();
})
micro_button.addEventListener('click', function(ev) {
	mcdump();
});

run_button.addEventListener('click', function(ev) {
	run_control(run_ctl == 0);
});
run_rate1.addEventListener('click', function(ev) { run_rate = 1; });
run_rate2.addEventListener('click', function(ev) { run_rate = 10; });
run_rate3.addEventListener('click', function(ev) { run_rate = 100; });
run_rate4.addEventListener('click', function(ev) { run_rate = 1000; });
run_rate5.addEventListener('click', function(ev) { run_rate = 10000; });
// can't handle this speed ;)
//run_rate6.addEventListener('click', function(ev) { run_rate = 100000; });
step_button.addEventListener('click', function(ev) {
	run_step = 1;
	run_follow = true;
	run_stop = function() {
		dis_vpc = mcstate.physaddr & 0x3ffff;
		//const pindex = ((mcstate.memaddr >> 11) & 31) | (mcstate.pta << 5);
		//const pgram = mcstate.page[pindex];
		//const pgaddr = (pgram & 127) | (((pgram & 112) == 112) ? 128 : 0);
		//dis_vpc = (pgaddr << 11) | (mcstate.memaddr & 0x7ff);
		show_disasm();
	}
	run_control(true);
});
microstep_button.addEventListener('click', function(ev) {
	mcstep(true);
	mcshowstate();
	if (dis_after) {
		show_disasm();
	}
});
btn_cm_import.addEventListener('click', function(ev) {
	annotation_import(txt_anno.value);
	show_disasm();
});
if ((document.getElementById('conv_ee') as HTMLInputElement).checked) {
	NAME_CONV = 0;
}
if ((document.getElementById('conv_mei') as HTMLInputElement).checked) {
	NAME_CONV = 1;
}
if ((document.getElementById('conv_uew') as HTMLInputElement).checked) {
	NAME_CONV = 2;
}
HEX_CONV = (document.getElementById('conv_hex') as HTMLInputElement).checked;
(document.getElementById('conv_ee') as HTMLInputElement).addEventListener('change', function(ev) {
	NAME_CONV = 0;
	show_disasm();
});
(document.getElementById('conv_mei') as HTMLInputElement).addEventListener('change', function(ev) {
	NAME_CONV = 1;
	show_disasm();
});
(document.getElementById('conv_uew') as HTMLInputElement).addEventListener('change', function(ev) {
	NAME_CONV = 2;
	show_disasm();
});
(document.getElementById('conv_hex') as HTMLInputElement).addEventListener('change', function(ev) {
	HEX_CONV = this.checked;
	show_disasm();
});
const inp_crtsize = document.getElementById('crtsize') as HTMLInputElement;
let TALL_CRT = inp_crtsize.checked;
inp_crtsize.addEventListener('change', function(ev) {
	TALL_CRT = this.checked;
	if (TALL_CRT) {
		cv_term0.classList.add('tall');
	} else {
		cv_term0.classList.remove('tall');
	}
});
if (TALL_CRT) {
	cv_term0.classList.add('tall');
} else {
	cv_term0.classList.remove('tall');
}

if (txt_anno.value.length > 0) {
	annotation_import(txt_anno.value);
}
mcdump();
show_disasm();

});
